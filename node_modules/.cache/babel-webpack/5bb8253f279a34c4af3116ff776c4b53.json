{"ast":null,"code":"import { ZipArchive, ZipArchiveItem } from '@syncfusion/ej2-compression';\nimport { Internationalization, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * CellStyle class\n * @private\n */\n\nclass CellStyle {\n  constructor() {\n    this.numFmtId = 0;\n    this.backColor = 'none';\n    this.fontName = 'Calibri';\n    this.fontSize = 10.5;\n    this.fontColor = '#000000';\n    this.italic = false;\n    this.bold = false;\n    this.underline = false;\n    this.wrapText = false;\n    this.hAlign = 'general';\n    this.vAlign = 'bottom';\n    this.indent = 0;\n    this.rotation = 0;\n    this.numberFormat = 'GENERAL';\n    this.type = 'datetime';\n    this.borders = new Borders();\n    this.isGlobalStyle = false;\n  }\n\n}\n/**\n * Font Class\n * @private\n */\n\n\nclass Font {\n  constructor() {\n    this.sz = 10.5;\n    this.name = 'Calibri';\n    this.u = false;\n    this.b = false;\n    this.i = false;\n    this.color = 'FF000000';\n  }\n\n}\n/**\n * CellXfs class\n * @private\n */\n\n\nclass CellXfs {}\n/**\n * Alignment class\n * @private\n */\n\n\nclass Alignment {}\n/**\n * CellStyleXfs class\n * @private\n */\n\n\nclass CellStyleXfs {}\n/**\n * CellStyles class\n * @private\n */\n\n\nclass CellStyles {\n  constructor() {\n    this.name = 'Normal';\n    this.xfId = 0;\n  }\n\n}\n/**\n * NumFmt class\n * @private\n */\n\n\nclass NumFmt {\n  constructor(id, code) {\n    this.numFmtId = id;\n    this.formatCode = code;\n  }\n\n}\n/**\n * Border class\n * @private\n */\n\n\nclass Border {\n  constructor(mLine, mColor) {\n    this.lineStyle = mLine;\n    this.color = mColor;\n  }\n\n}\n/**\n * Borders class\n * @private\n */\n\n\nclass Borders {\n  constructor() {\n    this.left = new Border('none', '#FFFFFF');\n    this.right = new Border('none', '#FFFFFF');\n    this.top = new Border('none', '#FFFFFF');\n    this.bottom = new Border('none', '#FFFFFF');\n    this.all = new Border('none', '#FFFFFF');\n  }\n\n}\n/**\n * Worksheet class\n * @private\n */\n\n\nclass Cell {}\n/**\n * Cells class\n * @private\n */\n\n\nclass Cells extends Array {\n  constructor() {\n    super(...arguments);\n\n    this.add = cell => {\n      let inserted = false;\n      let count = 0;\n\n      for (let c of this) {\n        if (c.index === cell.index) {\n          this[count] = cell;\n          inserted = true;\n        }\n\n        count++;\n      }\n\n      if (!inserted) {\n        this.push(cell);\n      }\n    };\n  }\n\n}\n/**\n * Column class\n * @private\n */\n\n\nclass Column {}\n/**\n * Row class\n * @private\n */\n\n\nclass Row {}\n/**\n * Rows class\n * @private\n */\n\n\nclass Rows extends Array {\n  constructor() {\n    super(...arguments);\n\n    this.add = row => {\n      this.push(row);\n    };\n  }\n\n}\n/**\n * Worksheets class\n * @private\n */\n\n\nclass Worksheets extends Array {}\n/**\n * Worksheet class\n * @private\n */\n\n\nclass Worksheet {\n  constructor() {\n    this.isSummaryRowBelow = true;\n    this.showGridLines = true;\n    this.enableRtl = false;\n  }\n\n}\n/**\n * Hyperlink class\n * @private\n */\n\n\nclass HyperLink {}\n/**\n * Grouping class\n * @private\n */\n\n\nclass Grouping {}\n/**\n * FreezePane class\n * @private\n */\n\n\nclass FreezePane {}\n/**\n * MergeCell\n * @private\n */\n\n\nclass MergeCell {}\n/**\n * MergeCells class\n * @private\n */\n\n\nclass MergeCells extends Array {\n  constructor() {\n    super(...arguments);\n\n    this.add = mergeCell => {\n      let inserted = false;\n      let count = 0;\n\n      for (let mCell of this) {\n        if (MergeCells.isIntersecting(mCell, mergeCell)) {\n          let intersectingCell = new MergeCell();\n          intersectingCell.x = Math.min(mCell.x, mergeCell.x);\n          intersectingCell.y = Math.min(mCell.Y, mergeCell.y);\n          intersectingCell.width = Math.max(mCell.Width + mCell.X, mergeCell.width + mergeCell.x);\n          intersectingCell.height = Math.max(mCell.Height + mCell.Y, mergeCell.height + mergeCell.y);\n          intersectingCell.ref = this[count].ref.split(':')[0] + ':' + mergeCell.ref.split(':')[1];\n          this[count] = intersectingCell;\n          mergeCell = intersectingCell;\n          inserted = true;\n        }\n\n        count++;\n      }\n\n      if (!inserted) {\n        this.push(mergeCell);\n      }\n\n      return mergeCell;\n    };\n  }\n\n  static isIntersecting(base, compare) {\n    return base.x <= compare.x + compare.width && compare.x <= base.x + base.width && base.y <= compare.y + compare.height && compare.y <= base.y + base.height;\n  }\n\n}\n/**\n * Image class\n * @private\n */\n\n\nclass Image {} // import { IValueFormatter } from '../base/interface';\n\n/**\n * ValueFormatter class to globalize the value.\n * @private\n */\n\n\nclass ValueFormatter {\n  constructor(cultureName) {\n    this.intl = new Internationalization(); // if (!isNullOrUndefined(cultureName)) {\n    //     this.intl.culture = cultureName;\n    // }\n  }\n\n  getFormatFunction(format, isServerRendered) {\n    if (format.type) {\n      if (isServerRendered) {\n        format.isServerRendered = true;\n      }\n\n      return this.intl.getDateFormat(format);\n    } else {\n      return this.intl.getNumberFormat(format);\n    }\n  } // public getParserFunction(format: NumberFormatOptions | DateFormatOptions): Function {\n  //     if ((<DateFormatOptions>format).type) {\n  //         return this.intl.getDateParser(<DateFormatOptions>format);\n  //     } else {\n  //         return this.intl.getNumberParser(<DateFormatOptions>format);\n  //     }\n  // }\n  // public fromView(value: string, format: Function, type?: string): string | number | Date {\n  //     if (type === 'date' || type === 'datetime' || type === 'number') {\n  //         return format(value);\n  //     } else {\n  //         return value;\n  //     }\n  // }\n\n\n  toView(value, format) {\n    let result = value;\n\n    if (!isNullOrUndefined(format) && !isNullOrUndefined(value)) {\n      result = format(value);\n    }\n\n    return result;\n  } // public setCulture(cultureName: string): void {\n  //     if (!isNullOrUndefined(cultureName)) {\n  //         setCulture(cultureName);\n  //     }\n  // }\n\n  /* tslint:disable:no-any */\n\n\n  displayText(value, format, isServerRendered) {\n    return this.toView(value, this.getFormatFunction(format, isServerRendered));\n  }\n\n}\n/**\n * CsvHelper class\n * @private\n */\n\n\nclass CsvHelper {\n  /* tslint:disable:no-any */\n  constructor(json, separator) {\n    this.csvStr = '';\n\n    if (separator === null || separator === undefined) {\n      this.separator = ',';\n    } else {\n      this.separator = separator;\n    }\n\n    this.formatter = new ValueFormatter();\n    this.isMicrosoftBrowser = !!navigator.msSaveBlob;\n\n    if (json.isServerRendered !== null && json.isServerRendered !== undefined) {\n      this.isServerRendered = json.isServerRendered;\n    }\n\n    if (json.styles !== null && json.styles !== undefined) {\n      this.globalStyles = new Map();\n\n      for (let i = 0; i < json.styles.length; i++) {\n        if (json.styles[i].name !== undefined && json.styles[i].numberFormat !== undefined) {\n          this.globalStyles.set(json.styles[i].name, json.styles[i].numberFormat);\n        }\n      }\n    } // Parses Worksheets data to DOM.        \n\n\n    if (json.worksheets !== null && json.worksheets !== undefined) {\n      this.parseWorksheet(json.worksheets[0]);\n    } //this.csvStr = 'a1,a2,a3\\nb1,b2,b3';\n\n  }\n\n  parseWorksheet(json) {\n    //Rows\n    if (json.rows !== null && json.rows !== undefined) {\n      this.parseRows(json.rows);\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parseRows(rows) {\n    let count = 1;\n\n    for (let row of rows) {\n      //Row index\n      if (row.index !== null && row.index !== undefined) {\n        while (count < row.index) {\n          this.csvStr += '\\n';\n          count++;\n        }\n\n        this.parseRow(row);\n      } else {\n        throw Error('Row index is missing.');\n      }\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parseRow(row) {\n    if (row.cells !== null && row.cells !== undefined) {\n      let count = 1;\n\n      for (let cell of row.cells) {\n        //cell index\n        if (cell.index !== null && cell.index !== undefined) {\n          while (count < cell.index) {\n            this.csvStr += this.separator;\n            count++;\n          }\n\n          this.parseCell(cell);\n        } else {\n          throw Error('Cell index is missing.');\n        }\n      }\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parseCell(cell) {\n    let csv = this.csvStr;\n\n    if (cell.value !== undefined) {\n      if (cell.value instanceof Date) {\n        if (cell.style !== undefined && cell.style.numberFormat !== undefined) {\n          /* tslint:disable-next-line:max-line-length */\n          try {\n            csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n              type: 'dateTime',\n              skeleton: cell.style.numberFormat\n            }, this.isServerRendered));\n          } catch (error) {\n            /* tslint:disable-next-line:max-line-length */\n            csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n              type: 'dateTime',\n              format: cell.style.numberFormat\n            }, this.isServerRendered));\n          }\n        } else if (cell.style !== undefined && cell.style.name !== undefined && this.globalStyles.has(cell.style.name)) {\n          /* tslint:disable-next-line:max-line-length */\n          try {\n            csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n              type: 'dateTime',\n              skeleton: this.globalStyles.get(cell.style.name)\n            }, this.isServerRendered));\n          } catch (error) {\n            /* tslint:disable-next-line:max-line-length */\n            csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n              type: 'dateTime',\n              format: this.globalStyles.get(cell.style.name)\n            }, this.isServerRendered));\n          }\n        } else {\n          csv += cell.value;\n        }\n      } else if (typeof cell.value === 'boolean') {\n        csv += cell.value ? 'TRUE' : 'FALSE';\n      } else if (typeof cell.value === 'number') {\n        if (cell.style !== undefined && cell.style.numberFormat !== undefined) {\n          /* tslint:disable-next-line:max-line-length */\n          csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n            format: cell.style.numberFormat\n          }, this.isServerRendered));\n        } else if (cell.style !== undefined && cell.style.name !== undefined && this.globalStyles.has(cell.style.name)) {\n          /* tslint:disable-next-line:max-line-length */\n          csv += this.parseCellValue(this.formatter.displayText(cell.value, {\n            format: this.globalStyles.get(cell.style.name)\n          }, this.isServerRendered));\n        } else {\n          csv += cell.value;\n        }\n      } else {\n        csv += this.parseCellValue(cell.value);\n      }\n    }\n\n    this.csvStr = csv;\n  }\n\n  parseCellValue(value) {\n    let val = '';\n    let length = value.length;\n\n    for (let start = 0; start < length; start++) {\n      if (value[start] === '\\\"') {\n        val += value[start].replace('\\\"', '\\\"\\\"');\n      } else {\n        val += value[start];\n      }\n    }\n\n    value = val;\n\n    if (value.indexOf(this.separator) !== -1 || value.indexOf('\\n') !== -1) {\n      return value = '\\\"' + value + '\\\"';\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName- file name to save.\n   * @param  {Blob} buffer- the content to write in file\n   */\n\n\n  save(fileName) {\n    this.buffer = new Blob(['\\ufeff' + this.csvStr], {\n      type: 'text/csv;charset=UTF-8'\n    });\n\n    if (this.isMicrosoftBrowser) {\n      navigator.msSaveBlob(this.buffer, fileName);\n    } else {\n      let dataUrl = window.URL.createObjectURL(this.buffer);\n      let dwlLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n      dwlLink.download = fileName;\n      dwlLink.href = dataUrl;\n      let event = document.createEvent('MouseEvent');\n      event.initEvent('click', true, true);\n      dwlLink.dispatchEvent(event);\n      setTimeout(() => {\n        window.URL.revokeObjectURL(dataUrl);\n      });\n    }\n  }\n\n  saveAsBlob() {\n    return new Blob(['\\ufeff' + this.csvStr], {\n      type: 'text/csv;charset=UTF-8'\n    });\n  }\n\n}\n/**\n * BlobHelper class\n * @private\n */\n\n\nclass BlobHelper {\n  constructor() {\n    /* tslint:disable:no-any */\n    this.parts = [];\n  }\n  /* tslint:disable:no-any */\n\n\n  append(part) {\n    this.parts.push(part);\n    this.blob = undefined; // Invalidate the blob\n  }\n\n  getBlob() {\n    return new Blob(this.parts, {\n      type: 'text/plain'\n    });\n  }\n\n}\n/**\n * AutoFilters class\n * @private\n */\n\n\nclass AutoFilters {}\n/**\n * Workbook class\n */\n\n\nclass Workbook {\n  /* tslint:disable:no-any */\n  constructor(json, saveType, culture, currencyString, separator) {\n    this.sharedStringCount = 0;\n    this.unitsProportions = [96 / 75.0, 96 / 300.0, 96, 96 / 25.4, 96 / 2.54, 1, 96 / 72.0, 96 / 72.0 / 12700];\n    /* tslint:disable:no-any */\n\n    this.hyperlinkStyle = {\n      fontColor: '#0000FF',\n      underline: true\n    };\n\n    if (culture !== undefined) {\n      this.culture = culture;\n    } else {\n      this.culture = 'en-US';\n    }\n\n    if (currencyString !== undefined) {\n      this.currency = currencyString;\n    } else {\n      this.currency = 'USD';\n    }\n\n    this.intl = new Internationalization(this.culture);\n    this.mSaveType = saveType;\n\n    if (saveType === 'xlsx') {\n      this.mArchive = new ZipArchive();\n      this.sharedString = [];\n      this.mFonts = [];\n      this.mBorders = [];\n      this.mStyles = [];\n      this.printTitles = new Map();\n      this.cellStyles = new Map();\n      this.mNumFmt = new Map();\n      this.mFills = new Map();\n      this.mStyles.push(new CellStyle());\n      this.mFonts.push(new Font());\n      /* tslint:disable */\n\n      this.cellStyles.set('Normal', new CellStyles());\n      /* tslint:enable */\n\n      this.mCellXfs = [];\n      this.mCellStyleXfs = [];\n      this.drawingCount = 0;\n      this.imageCount = 0;\n\n      if (json.styles !== null && json.styles !== undefined) {\n        /* tslint:disable-next-line:no-any */\n        this.globalStyles = new Map();\n\n        for (let i = 0; i < json.styles.length; i++) {\n          if (json.styles[i].name !== undefined) {\n            if (!this.cellStyles.has(json.styles[i].name)) {\n              let cellStyle = new CellStyle();\n              cellStyle.isGlobalStyle = true;\n              this.parserCellStyle(json.styles[i], cellStyle, 'none');\n              let cellStylesIn = new CellStyles();\n              cellStylesIn.name = cellStyle.name;\n              cellStylesIn.xfId = cellStyle.index - 1;\n              this.cellStyles.set(cellStylesIn.name, cellStylesIn);\n              /* tslint:disable-next-line:no-any */\n\n              let tFormat = {};\n\n              if (json.styles[i].numberFormat !== undefined) {\n                tFormat.format = json.styles[i].numberFormat;\n              }\n\n              if (json.styles[i].type !== undefined) {\n                tFormat.type = json.styles[i].type;\n              } else {\n                tFormat.type = 'datetime';\n              }\n\n              if (tFormat.format !== undefined) {\n                this.globalStyles.set(json.styles[i].name, tFormat);\n              }\n            } else {\n              throw Error('Style name ' + json.styles[i].name + ' is already existed');\n            }\n          }\n        }\n      } // Parses Worksheets data to DOM.        \n\n\n      if (json.worksheets !== null && json.worksheets !== undefined) {\n        this.parserWorksheets(json.worksheets);\n      } else {\n        throw Error('Worksheet is expected.');\n      } // Parses the BuiltInProperties data to DOM.        \n\n\n      if (json.builtInProperties !== null && json.builtInProperties !== undefined) {\n        this.builtInProperties = new BuiltInProperties();\n        this.parserBuiltInProperties(json.builtInProperties, this.builtInProperties);\n      }\n    } else {\n      this.csvHelper = new CsvHelper(json, separator);\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parserBuiltInProperties(jsonBuiltInProperties, builtInProperties) {\n    //Author\n    if (jsonBuiltInProperties.author !== null && jsonBuiltInProperties.author !== undefined) {\n      builtInProperties.author = jsonBuiltInProperties.author;\n    } //Comments\n\n\n    if (jsonBuiltInProperties.comments !== null && jsonBuiltInProperties.comments !== undefined) {\n      builtInProperties.comments = jsonBuiltInProperties.comments;\n    } //Category\n\n\n    if (jsonBuiltInProperties.category !== null && jsonBuiltInProperties.category !== undefined) {\n      builtInProperties.category = jsonBuiltInProperties.category;\n    } //Company\n\n\n    if (jsonBuiltInProperties.company !== null && jsonBuiltInProperties.company !== undefined) {\n      builtInProperties.company = jsonBuiltInProperties.company;\n    } //Manager\n\n\n    if (jsonBuiltInProperties.manager !== null && jsonBuiltInProperties.manager !== undefined) {\n      builtInProperties.manager = jsonBuiltInProperties.manager;\n    } //Subject\n\n\n    if (jsonBuiltInProperties.subject !== null && jsonBuiltInProperties.subject !== undefined) {\n      builtInProperties.subject = jsonBuiltInProperties.subject;\n    } //Title\n\n\n    if (jsonBuiltInProperties.title !== null && jsonBuiltInProperties.title !== undefined) {\n      builtInProperties.title = jsonBuiltInProperties.title;\n    } //Creation date\n\n\n    if (jsonBuiltInProperties.createdDate !== null && jsonBuiltInProperties.createdDate !== undefined) {\n      builtInProperties.createdDate = jsonBuiltInProperties.createdDate;\n    } //Modified date\n\n\n    if (jsonBuiltInProperties.modifiedDate !== null && jsonBuiltInProperties.modifiedDate !== undefined) {\n      builtInProperties.modifiedDate = jsonBuiltInProperties.modifiedDate;\n    } //Tags\n\n\n    if (jsonBuiltInProperties.tags !== null && jsonBuiltInProperties.tags !== undefined) {\n      builtInProperties.tags = jsonBuiltInProperties.tags;\n    } //Status\n\n\n    if (jsonBuiltInProperties.status !== null && jsonBuiltInProperties.status !== undefined) {\n      builtInProperties.status = jsonBuiltInProperties.status;\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parserWorksheets(json) {\n    this.worksheets = new Worksheets();\n    let length = json.length;\n\n    for (let i = 0; i < length; i++) {\n      let jsonSheet = json[i];\n      let sheet = new Worksheet();\n      this.mergeCells = new MergeCells();\n      this.mergedCellsStyle = new Map();\n      this.mHyperLinks = []; //Name\n\n      if (jsonSheet.name !== null && jsonSheet.name !== undefined) {\n        sheet.name = jsonSheet.name;\n      } else {\n        sheet.name = 'Sheet' + (i + 1).toString();\n      }\n\n      if (jsonSheet.enableRtl !== null && jsonSheet.enableRtl !== undefined) {\n        sheet.enableRtl = jsonSheet.enableRtl;\n      }\n\n      sheet.index = i + 1; //Columns\n\n      if (jsonSheet.columns !== null && jsonSheet.columns !== undefined) {\n        this.parserColumns(jsonSheet.columns, sheet);\n      } //Rows\n\n\n      if (jsonSheet.rows !== null && jsonSheet.rows !== undefined) {\n        this.parserRows(jsonSheet.rows, sheet);\n      } //showGridLines\n\n\n      if (jsonSheet.showGridLines !== null && jsonSheet.showGridLines !== undefined) {\n        sheet.showGridLines = jsonSheet.showGridLines;\n      } //FreezePanes\n\n\n      if (jsonSheet.freeze !== null && jsonSheet.freeze !== undefined) {\n        this.parserFreezePanes(jsonSheet.freeze, sheet);\n      } //Print Title\n\n\n      if (jsonSheet.printTitle !== null && jsonSheet.printTitle !== undefined) {\n        this.parserPrintTitle(jsonSheet.printTitle, sheet);\n      }\n\n      if (jsonSheet.pageSetup !== undefined) {\n        if (jsonSheet.pageSetup.isSummaryRowBelow !== undefined) {\n          sheet.isSummaryRowBelow = jsonSheet.pageSetup.isSummaryRowBelow;\n        }\n      }\n\n      if (jsonSheet.images !== undefined) {\n        this.parserImages(jsonSheet.images, sheet);\n      }\n\n      if (jsonSheet.autoFilters !== null && jsonSheet.autoFilters !== undefined) {\n        this.parseFilters(jsonSheet.autoFilters, sheet);\n      }\n\n      sheet.index = i + 1;\n      sheet.mergeCells = this.mergeCells;\n      sheet.hyperLinks = this.mHyperLinks;\n      this.worksheets.push(sheet);\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  mergeOptions(fromJson, toJson) {\n    /* tslint:disable:no-any */\n    let result = {};\n    this.applyProperties(fromJson, result);\n    this.applyProperties(toJson, result);\n    return result;\n  }\n  /* tslint:disable:no-any */\n\n\n  applyProperties(sourceJson, destJson) {\n    let keys = Object.keys(sourceJson);\n\n    for (let index = 0; index < keys.length; index++) {\n      if (keys[index] !== 'name') {\n        destJson[keys[index]] = sourceJson[keys[index]];\n      }\n    }\n  }\n\n  getCellName(row, column) {\n    return this.getColumnName(column) + row.toString();\n  }\n\n  getColumnName(col) {\n    col--;\n    let strColumnName = '';\n\n    do {\n      let iCurrentDigit = col % 26;\n      col = col / 26 - 1;\n      strColumnName = String.fromCharCode(65 + iCurrentDigit) + strColumnName;\n    } while (col >= 0);\n\n    return strColumnName;\n  }\n  /* tslint:disable:no-any */\n\n\n  parserPrintTitle(json, sheet) {\n    let printTitleName = '';\n    let titleRowName;\n\n    if (json.fromRow !== null && json.fromRow !== undefined) {\n      let fromRow = json.fromRow;\n      let toRow;\n\n      if (json.toRow !== null && json.toRow !== undefined) {\n        toRow = json.toRow;\n      } else {\n        toRow = json.fromRow;\n      }\n\n      titleRowName = '$' + fromRow + ':$' + toRow;\n    }\n\n    let titleColName;\n\n    if (json.fromColumn !== null && json.fromColumn !== undefined) {\n      let fromColumn = json.fromColumn;\n      let toColumn;\n\n      if (json.toColumn !== null && json.toColumn !== undefined) {\n        toColumn = json.toColumn;\n      } else {\n        toColumn = json.fromColumn;\n      }\n\n      titleColName = '$' + this.getColumnName(fromColumn) + ':$' + this.getColumnName(toColumn);\n    }\n\n    if (titleRowName !== undefined) {\n      printTitleName += sheet.name + '!' + titleRowName;\n    }\n\n    if (titleColName !== undefined && titleRowName !== undefined) {\n      printTitleName += ',' + (sheet.name + '!' + titleColName);\n    } else if (titleColName !== undefined) {\n      printTitleName += sheet.name + '!' + titleColName;\n    }\n\n    if (printTitleName !== '') {\n      this.printTitles.set(sheet.index - 1, printTitleName);\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parserFreezePanes(json, sheet) {\n    sheet.freezePanes = new FreezePane();\n\n    if (json.row !== null && json.row !== undefined) {\n      sheet.freezePanes.row = json.row;\n    } else {\n      sheet.freezePanes.row = 0;\n    }\n\n    if (json.column !== null && json.column !== undefined) {\n      sheet.freezePanes.column = json.column;\n    } else {\n      sheet.freezePanes.column = 0;\n    }\n\n    sheet.freezePanes.leftCell = this.getCellName(sheet.freezePanes.row + 1, sheet.freezePanes.column + 1);\n  }\n  /* tslint:disable:no-any */\n\n\n  parserColumns(json, sheet) {\n    let columnsLength = json.length;\n    sheet.columns = [];\n\n    for (let column = 0; column < columnsLength; column++) {\n      let col = new Column();\n\n      if (json[column].index !== null && json[column].index !== undefined) {\n        col.index = json[column].index;\n      } else {\n        throw Error('Column index is missing.');\n      }\n\n      if (json[column].width !== null && json[column].width !== undefined) {\n        col.width = json[column].width;\n      }\n\n      sheet.columns.push(col);\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parserRows(json, sheet) {\n    let rowsLength = json.length;\n    sheet.rows = new Rows();\n    let rowId = 0;\n\n    for (let r = 0; r < rowsLength; r++) {\n      let row = this.parserRow(json[r], rowId);\n      rowId = row.index;\n      sheet.rows.add(row);\n    }\n\n    this.insertMergedCellsStyle(sheet);\n  }\n\n  insertMergedCellsStyle(sheet) {\n    if (this.mergeCells.length > 0) {\n      this.mergedCellsStyle.forEach((value, key) => {\n        let row = sheet.rows.filter(item => {\n          return item.index === value.y;\n        })[0];\n\n        if (!isNullOrUndefined(row)) {\n          let cell = row.cells.filter(item => {\n            return item.index === value.x;\n          })[0];\n\n          if (!isNullOrUndefined(cell)) {\n            cell.styleIndex = value.styleIndex;\n          } else {\n            let cells = row.cells.filter(item => {\n              return item.index <= value.x;\n            });\n            let insertIndex = 0;\n\n            if (cells.length > 0) {\n              insertIndex = row.cells.indexOf(cells[cells.length - 1]) + 1;\n            }\n\n            row.cells.splice(insertIndex, 0, this.createCell(value, key));\n          }\n        } else {\n          let rows = sheet.rows.filter(item => {\n            return item.index <= value.y;\n          });\n          let rowToInsert = new Row();\n          rowToInsert.index = value.y;\n          rowToInsert.cells = new Cells();\n          rowToInsert.cells.add(this.createCell(value, key));\n          let insertIndex = 0;\n\n          if (rows.length > 0) {\n            insertIndex = sheet.rows.indexOf(rows[rows.length - 1]) + 1;\n          }\n\n          sheet.rows.splice(insertIndex, 0, rowToInsert);\n        }\n      });\n    }\n  }\n\n  createCell(value, key) {\n    let cellToInsert = new Cell();\n    cellToInsert.refName = key;\n    cellToInsert.index = value.x;\n    cellToInsert.cellStyle = new CellStyle();\n    cellToInsert.styleIndex = value.styleIndex;\n    return cellToInsert;\n  }\n  /* tslint:disable:no-any */\n\n\n  parserRow(json, rowIndex) {\n    let row = new Row(); //Row Height\n\n    if (json.height !== null && json.height !== undefined) {\n      row.height = json.height;\n    } //Row index\n\n\n    if (json.index !== null && json.index !== undefined) {\n      row.index = json.index;\n    } else {\n      throw Error('Row index is missing.');\n    }\n\n    if (json.grouping !== null && json.grouping !== undefined) {\n      this.parseGrouping(json.grouping, row);\n    }\n\n    this.parseCells(json.cells, row);\n    return row;\n  }\n  /* tslint:disable:no-any */\n\n\n  parseGrouping(json, row) {\n    row.grouping = new Grouping();\n\n    if (json.outlineLevel !== undefined) {\n      row.grouping.outlineLevel = json.outlineLevel;\n    }\n\n    if (json.isCollapsed !== undefined) {\n      row.grouping.isCollapsed = json.isCollapsed;\n    }\n\n    if (json.isHidden !== undefined) {\n      row.grouping.isHidden = json.isHidden;\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parseCells(json, row) {\n    row.cells = new Cells();\n    let cellsLength = json !== undefined ? json.length : 0;\n    let spanMin = 1;\n    let spanMax = 1;\n\n    for (let cellId = 0; cellId < cellsLength; cellId++) {\n      /* tslint:disable:no-any */\n      let jsonCell = json[cellId];\n      let cell = new Cell(); //cell index\n\n      if (jsonCell.index !== null && jsonCell.index !== undefined) {\n        cell.index = jsonCell.index;\n      } else {\n        throw Error('Cell index is missing.');\n      }\n\n      if (cell.index < spanMin) {\n        spanMin = cell.index;\n      } else if (cell.index > spanMax) {\n        spanMax = cell.index;\n      } //Update the Cell name\n\n\n      cell.refName = this.getCellName(row.index, cell.index); //Row span\n\n      if (jsonCell.rowSpan !== null && jsonCell.rowSpan !== undefined) {\n        cell.rowSpan = jsonCell.rowSpan - 1;\n      } else {\n        cell.rowSpan = 0;\n      } //Column span\n\n\n      if (jsonCell.colSpan !== null && jsonCell.colSpan !== undefined) {\n        cell.colSpan = jsonCell.colSpan - 1;\n      } else {\n        cell.colSpan = 0;\n      } //Hyperlink\n\n\n      if (jsonCell.hyperlink !== null && jsonCell.hyperlink !== undefined) {\n        let hyperLink = new HyperLink();\n\n        if (jsonCell.hyperlink.target !== undefined) {\n          hyperLink.target = jsonCell.hyperlink.target;\n\n          if (jsonCell.hyperlink.displayText !== undefined) {\n            cell.value = jsonCell.hyperlink.displayText;\n          } else {\n            cell.value = jsonCell.hyperlink.target;\n          }\n\n          cell.type = this.getCellValueType(cell.value);\n          hyperLink.ref = cell.refName;\n          hyperLink.rId = this.mHyperLinks.length + 1;\n          this.mHyperLinks.push(hyperLink);\n          cell.cellStyle = new CellStyle();\n          /* tslint:disable-next-line:max-line-length */\n\n          this.parserCellStyle(jsonCell.style !== undefined ? this.mergeOptions(jsonCell.style, this.hyperlinkStyle) : this.hyperlinkStyle, cell.cellStyle, 'string');\n          cell.styleIndex = cell.cellStyle.index;\n        }\n      } // formulas\n\n\n      if (jsonCell.formula !== null && jsonCell.formula !== undefined) {\n        cell.formula = jsonCell.formula;\n        cell.type = 'formula';\n      } //Cell value\n\n\n      if (jsonCell.value !== null && jsonCell.value !== undefined) {\n        if (cell.formula !== undefined) {\n          cell.value = 0;\n        } else {\n          cell.value = jsonCell.value;\n          cell.type = this.getCellValueType(cell.value);\n        }\n      }\n\n      if (jsonCell.style !== null && jsonCell.style !== undefined && cell.styleIndex === undefined) {\n        cell.cellStyle = new CellStyle();\n\n        if (cell.value instanceof Date) {\n          this.parserCellStyle(jsonCell.style, cell.cellStyle, cell.type, 14);\n        } else {\n          this.parserCellStyle(jsonCell.style, cell.cellStyle, cell.type);\n        }\n\n        cell.styleIndex = cell.cellStyle.index;\n      } else if (cell.value instanceof Date) {\n        cell.cellStyle = new CellStyle();\n        this.parserCellStyle({}, cell.cellStyle, cell.type, 14);\n        cell.styleIndex = cell.cellStyle.index;\n      }\n\n      this.parseCellType(cell);\n      this.mergeCells = this.processMergeCells(cell, row.index, this.mergeCells);\n      row.cells.add(cell);\n    }\n\n    row.spans = spanMin + ':' + spanMax;\n  }\n\n  GetColors() {\n    let colors;\n    colors = new Map();\n    /* tslint:disable */\n\n    colors.set('WHITE', 'FFFFFFFF');\n    /* tslint:disable */\n\n    colors.set('SILVER', 'FFC0C0C0');\n    /* tslint:disable */\n\n    colors.set('GRAY', 'FF808080');\n    /* tslint:disable */\n\n    colors.set('BLACK', 'FF000000');\n    /* tslint:disable */\n\n    colors.set('RED', 'FFFF0000');\n    /* tslint:disable */\n\n    colors.set('MAROON', 'FF800000');\n    /* tslint:disable */\n\n    colors.set('YELLOW', 'FFFFFF00');\n    /* tslint:disable */\n\n    colors.set('OLIVE', 'FF808000');\n    /* tslint:disable */\n\n    colors.set('LIME', 'FF00FF00');\n    /* tslint:disable */\n\n    colors.set('GREEN', 'FF008000');\n    /* tslint:disable */\n\n    colors.set('AQUA', 'FF00FFFF');\n    /* tslint:disable */\n\n    colors.set('TEAL', 'FF008080');\n    /* tslint:disable */\n\n    colors.set('BLUE', 'FF0000FF');\n    /* tslint:disable */\n\n    colors.set('NAVY', 'FF000080');\n    /* tslint:disable */\n\n    colors.set('FUCHSIA', 'FFFF00FF');\n    /* tslint:disable */\n\n    colors.set('PURPLE', 'FF800080');\n    return colors;\n  }\n\n  processColor(colorVal) {\n    if (colorVal.indexOf('#') === 0) {\n      return colorVal.replace('#', 'FF');\n    }\n\n    colorVal = colorVal.toUpperCase();\n    this.rgbColors = this.GetColors();\n\n    if (this.rgbColors.has(colorVal)) {\n      colorVal = this.rgbColors.get(colorVal);\n    } else {\n      colorVal = 'FF000000';\n    }\n\n    return colorVal;\n  }\n\n  processCellValue(value, cell) {\n    let cellValue = value;\n\n    if (value.indexOf(\"<font\") !== -1 || value.indexOf(\"<a\") !== -1 || value.indexOf(\"<b>\") !== -1 || value.indexOf(\"<i>\") !== -1 || value.indexOf(\"<u>\") !== -1) {\n      let processedVal = '';\n      let startindex = value.indexOf('<', 0);\n      let endIndex = value.indexOf('>', startindex + 1);\n\n      if (startindex >= 0 && endIndex >= 0) {\n        if (startindex !== 0) {\n          processedVal += '<r><t xml:space=\"preserve\">' + this.processString(value.substring(0, startindex)) + '</t></r>';\n        }\n\n        while (startindex >= 0 && endIndex >= 0) {\n          endIndex = value.indexOf('>', startindex + 1);\n\n          if (endIndex >= 0) {\n            let subString = value.substring(startindex + 1, endIndex);\n            startindex = value.indexOf('<', endIndex + 1);\n\n            if (startindex < 0) {\n              startindex = cellValue.length;\n            }\n\n            let text = cellValue.substring(endIndex + 1, startindex);\n\n            if (text.length !== 0) {\n              let subSplit = subString.split(' ');\n\n              if (subSplit.length > 0) {\n                processedVal += '<r><rPr>';\n              }\n\n              if (subSplit.length > 1) {\n                for (let element of subSplit) {\n                  let start = element.trim().substring(0, 5);\n\n                  switch (start) {\n                    case 'size=':\n                      processedVal += '<sz val=\"' + element.substring(6, element.length - 1) + '\"/>';\n                      break;\n\n                    case 'face=':\n                      processedVal += '<rFont val=\"' + element.substring(6, element.length - 1) + '\"/>';\n                      break;\n\n                    case 'color':\n                      processedVal += '<color rgb=\"' + this.processColor(element.substring(7, element.length - 1)) + '\"/>';\n                      break;\n\n                    case 'href=':\n                      let hyperLink = new HyperLink();\n                      hyperLink.target = element.substring(6, element.length - 1).trim();\n                      hyperLink.ref = cell.refName;\n                      hyperLink.rId = this.mHyperLinks.length + 1;\n                      this.mHyperLinks.push(hyperLink);\n                      processedVal += '<color rgb=\"FF0000FF\"/><u/><b/>';\n                      break;\n                  }\n                }\n              } else if (subSplit.length === 1) {\n                let style = subSplit[0].trim();\n\n                switch (style) {\n                  case 'b':\n                    processedVal += '<b/>';\n                    break;\n\n                  case 'i':\n                    processedVal += '<i/>';\n                    break;\n\n                  case 'u':\n                    processedVal += '<u/>';\n                    break;\n                }\n              }\n\n              processedVal += '</rPr><t xml:space=\"preserve\">' + this.processString(text) + '</t></r>';\n            }\n          }\n        }\n\n        if (processedVal === '') {\n          return cellValue;\n        }\n\n        return processedVal;\n      } else {\n        return cellValue;\n      }\n    } else {\n      return cellValue;\n    }\n  }\n\n  applyGlobalStyle(json, cellStyle) {\n    if (this.cellStyles.has(json.name)) {\n      cellStyle.index = this.mStyles.filter(a => a.name === json.name)[0].index;\n      cellStyle.name = json.name;\n    }\n  }\n  /* tslint:disable:no-any */\n\n\n  parserCellStyle(json, cellStyle, cellType, defStyleIndex) {\n    //name\n    if (json.name !== null && json.name !== undefined) {\n      if (cellStyle.isGlobalStyle) {\n        cellStyle.name = json.name;\n      } else {\n        this.applyGlobalStyle(json, cellStyle);\n        return;\n      }\n    } //background color\n\n\n    if (json.backColor !== null && json.backColor !== undefined) {\n      cellStyle.backColor = json.backColor;\n    } //borders\n    //leftBorder\n\n\n    cellStyle.borders = new Borders(); //AllBorder\n\n    if (json.borders !== null && json.borders !== undefined) {\n      this.parserBorder(json.borders, cellStyle.borders.all);\n    } //leftborder\n\n\n    if (json.leftBorder !== null && json.leftBorder !== undefined) {\n      this.parserBorder(json.leftBorder, cellStyle.borders.left);\n    } //rightBorder\n\n\n    if (json.rightBorder !== null && json.rightBorder !== undefined) {\n      this.parserBorder(json.rightBorder, cellStyle.borders.right);\n    } //topBorder\n\n\n    if (json.topBorder !== null && json.topBorder !== undefined) {\n      this.parserBorder(json.topBorder, cellStyle.borders.top);\n    } //bottomBorder\n\n\n    if (json.bottomBorder !== null && json.bottomBorder !== undefined) {\n      this.parserBorder(json.bottomBorder, cellStyle.borders.bottom);\n    } //fontName\n\n\n    if (json.fontName !== null && json.fontName !== undefined) {\n      cellStyle.fontName = json.fontName;\n    } //fontSize\n\n\n    if (json.fontSize !== null && json.fontSize !== undefined) {\n      cellStyle.fontSize = json.fontSize;\n    } //fontColor\n\n\n    if (json.fontColor !== null && json.fontColor !== undefined) {\n      cellStyle.fontColor = json.fontColor;\n    } //italic\n\n\n    if (json.italic !== null && json.italic !== undefined) {\n      cellStyle.italic = json.italic;\n    } //bold\n\n\n    if (json.bold !== null && json.bold !== undefined) {\n      cellStyle.bold = json.bold;\n    } //hAlign\n\n\n    if (json.hAlign !== null && json.hAlign !== undefined) {\n      cellStyle.hAlign = json.hAlign.toLowerCase();\n    } //indent\n\n\n    if (json.indent !== null && json.indent !== undefined) {\n      cellStyle.indent = json.indent;\n\n      if (!(cellStyle.hAlign === 'left' || cellStyle.hAlign === 'right')) {\n        cellStyle.hAlign = 'left';\n      }\n    }\n\n    if (json.rotation !== null && json.rotation !== undefined) {\n      cellStyle.rotation = json.rotation;\n    } //vAlign\n\n\n    if (json.vAlign !== null && json.vAlign !== undefined) {\n      cellStyle.vAlign = json.vAlign.toLowerCase();\n    } //underline\n\n\n    if (json.underline !== null && json.underline !== undefined) {\n      cellStyle.underline = json.underline;\n    } //wrapText\n\n\n    if (json.wrapText !== null && json.wrapText !== undefined) {\n      cellStyle.wrapText = json.wrapText;\n    } //numberFormat\n\n\n    if (json.numberFormat !== null && json.numberFormat !== undefined) {\n      if (json.type !== null && json.type !== undefined) {\n        cellStyle.numberFormat = this.getNumberFormat(json.numberFormat, json.type);\n      } else {\n        cellStyle.numberFormat = this.getNumberFormat(json.numberFormat, cellType);\n      }\n    } else if (defStyleIndex !== undefined) {\n      cellStyle.numFmtId = 14;\n      cellStyle.numberFormat = 'GENERAL';\n    } else {\n      cellStyle.numberFormat = 'GENERAL';\n    }\n\n    cellStyle.index = this.processCellStyle(cellStyle);\n  }\n\n  switchNumberFormat(numberFormat, type) {\n    let format = this.getNumberFormat(numberFormat, type);\n\n    if (format !== numberFormat) {\n      let numFmt = this.mNumFmt.get(numberFormat);\n\n      if (numFmt !== undefined) {\n        numFmt.formatCode = format;\n\n        if (this.mNumFmt.has(format)) {\n          for (let cellStyleXfs of this.mCellStyleXfs) {\n            if (cellStyleXfs.numFmtId === numFmt.numFmtId) {\n              cellStyleXfs.numFmtId = this.mNumFmt.get(format).numFmtId;\n            }\n          }\n\n          for (let cellXfs of this.mCellXfs) {\n            if (cellXfs.numFmtId === numFmt.numFmtId) {\n              cellXfs.numFmtId = this.mNumFmt.get(format).numFmtId;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  getNumberFormat(numberFormat, type) {\n    let returnFormat;\n\n    switch (type) {\n      case 'number':\n        try {\n          returnFormat = this.intl.getNumberPattern({\n            format: numberFormat,\n            currency: this.currency,\n            useGrouping: true\n          }, true);\n        } catch (error) {\n          returnFormat = numberFormat;\n        }\n\n        break;\n\n      case 'datetime':\n        try {\n          returnFormat = this.intl.getDatePattern({\n            skeleton: numberFormat,\n            type: 'dateTime'\n          }, true);\n        } catch (error) {\n          try {\n            returnFormat = this.intl.getDatePattern({\n              format: numberFormat,\n              type: 'dateTime'\n            }, true);\n          } catch (error) {\n            returnFormat = numberFormat;\n          }\n        }\n\n        break;\n\n      case 'date':\n        try {\n          returnFormat = this.intl.getDatePattern({\n            skeleton: numberFormat,\n            type: 'date'\n          }, true);\n        } catch (error) {\n          try {\n            returnFormat = this.intl.getDatePattern({\n              format: numberFormat,\n              type: 'date'\n            }, true);\n          } catch (error) {\n            returnFormat = numberFormat;\n          }\n        }\n\n        break;\n\n      case 'time':\n        try {\n          returnFormat = this.intl.getDatePattern({\n            skeleton: numberFormat,\n            type: 'time'\n          }, true);\n        } catch (error) {\n          try {\n            returnFormat = this.intl.getDatePattern({\n              format: numberFormat,\n              type: 'time'\n            }, true);\n          } catch (error) {\n            returnFormat = numberFormat;\n          }\n        }\n\n        break;\n\n      default:\n        returnFormat = numberFormat;\n        break;\n    }\n\n    return returnFormat;\n  }\n  /* tslint:disable:no-any */\n\n\n  parserBorder(json, border) {\n    if (json.color !== null && json.color !== undefined) {\n      border.color = json.color;\n    } else {\n      border.color = '#000000';\n    }\n\n    if (json.lineStyle !== null && json.lineStyle !== undefined) {\n      border.lineStyle = json.lineStyle;\n    } else {\n      border.lineStyle = 'thin';\n    }\n  }\n\n  processCellStyle(style) {\n    if (style.isGlobalStyle) {\n      this.processNumFormatId(style);\n      this.mStyles.push(style);\n      return this.mStyles.length;\n    } else {\n      let compareResult = this.compareStyle(style);\n\n      if (!compareResult.result) {\n        this.processNumFormatId(style);\n        this.mStyles.push(style);\n        return this.mStyles.length;\n      } else {\n        //Return the index of the already existing style.\n        return compareResult.index;\n      }\n    }\n  }\n\n  processNumFormatId(style) {\n    if (style.numberFormat !== 'GENERAL' && !this.mNumFmt.has(style.numberFormat)) {\n      let id = this.mNumFmt.size + 164;\n      this.mNumFmt.set(style.numberFormat, new NumFmt(id, style.numberFormat));\n    }\n  }\n\n  isNewFont(toCompareStyle) {\n    let result = false;\n    let index = 0;\n\n    for (let font of this.mFonts) {\n      index++;\n      let fontColor = undefined;\n\n      if (toCompareStyle.fontColor !== undefined) {\n        fontColor = 'FF' + toCompareStyle.fontColor.replace('#', '');\n      }\n\n      result = font.color === fontColor && font.b === toCompareStyle.bold && font.i === toCompareStyle.italic && font.u === toCompareStyle.underline && font.name === toCompareStyle.fontName && font.sz === toCompareStyle.fontSize;\n\n      if (result) {\n        break;\n      }\n    }\n\n    index = index - 1;\n    return {\n      index,\n      result\n    };\n  }\n\n  isNewBorder(toCompareStyle) {\n    let bStyle = new CellStyle();\n\n    if (this.isAllBorder(toCompareStyle.borders)) {\n      return bStyle.borders.all.color === toCompareStyle.borders.all.color && bStyle.borders.all.lineStyle === toCompareStyle.borders.all.lineStyle;\n    } else {\n      return bStyle.borders.left.color === toCompareStyle.borders.left.color && bStyle.borders.left.lineStyle === toCompareStyle.borders.left.lineStyle && bStyle.borders.right.color === toCompareStyle.borders.right.color && bStyle.borders.right.lineStyle === toCompareStyle.borders.right.lineStyle && bStyle.borders.top.color === toCompareStyle.borders.top.color && bStyle.borders.top.lineStyle === toCompareStyle.borders.top.lineStyle && bStyle.borders.bottom.color === toCompareStyle.borders.bottom.color && bStyle.borders.bottom.lineStyle === toCompareStyle.borders.bottom.lineStyle;\n    }\n  }\n\n  isAllBorder(toCompareBorder) {\n    let allBorderStyle = new CellStyle();\n    return allBorderStyle.borders.all.color !== toCompareBorder.all.color && allBorderStyle.borders.all.lineStyle !== toCompareBorder.all.lineStyle;\n  }\n\n  compareStyle(toCompareStyle) {\n    let result = true;\n    let index = 0;\n\n    for (let baseStyle of this.mStyles) {\n      result = baseStyle.isGlobalStyle ? false : baseStyle.backColor === toCompareStyle.backColor && baseStyle.bold === toCompareStyle.bold && baseStyle.numFmtId === toCompareStyle.numFmtId && baseStyle.numberFormat === toCompareStyle.numberFormat && baseStyle.type === toCompareStyle.type && baseStyle.fontColor === toCompareStyle.fontColor && baseStyle.fontName === toCompareStyle.fontName && baseStyle.fontSize === toCompareStyle.fontSize && baseStyle.hAlign === toCompareStyle.hAlign && baseStyle.italic === toCompareStyle.italic && baseStyle.underline === toCompareStyle.underline && baseStyle.vAlign === toCompareStyle.vAlign && baseStyle.indent === toCompareStyle.indent && baseStyle.rotation === toCompareStyle.rotation && baseStyle.wrapText === toCompareStyle.wrapText && baseStyle.borders.all.color === toCompareStyle.borders.all.color && baseStyle.borders.all.lineStyle === toCompareStyle.borders.all.lineStyle && baseStyle.borders.left.color === toCompareStyle.borders.left.color && baseStyle.borders.left.lineStyle === toCompareStyle.borders.left.lineStyle && baseStyle.borders.right.color === toCompareStyle.borders.right.color && baseStyle.borders.right.lineStyle === toCompareStyle.borders.right.lineStyle && baseStyle.borders.top.color === toCompareStyle.borders.top.color && baseStyle.borders.top.lineStyle === toCompareStyle.borders.top.lineStyle && baseStyle.borders.bottom.color === toCompareStyle.borders.bottom.color && baseStyle.borders.bottom.lineStyle === toCompareStyle.borders.bottom.lineStyle;\n\n      if (result) {\n        index = baseStyle.index;\n        break;\n      }\n    }\n\n    return {\n      index,\n      result\n    };\n  }\n\n  contains(array, item) {\n    let index = array.indexOf(item);\n    return index > -1 && index < array.length;\n  }\n\n  getCellValueType(value) {\n    if (value instanceof Date) {\n      return 'datetime';\n    } else if (typeof value === 'boolean') {\n      return 'boolean';\n    } else if (typeof value === 'number') {\n      return 'number';\n    } else {\n      return 'string';\n    }\n  }\n\n  parseCellType(cell) {\n    let type = cell.type;\n    let saveType;\n    let value = cell.value;\n\n    switch (type) {\n      case 'datetime':\n        value = this.toOADate(value);\n\n        if (cell.cellStyle !== undefined && cell.cellStyle.name !== undefined) {\n          if (this.globalStyles.has(cell.cellStyle.name)) {\n            let value = this.globalStyles.get(cell.cellStyle.name);\n            this.switchNumberFormat(value.format, value.type);\n          }\n        }\n\n        saveType = 'n';\n        break;\n      //TODO: Update the number format index and style\n\n      case 'boolean':\n        value = value ? 1 : 0;\n        saveType = 'b';\n        break;\n\n      case 'number':\n        saveType = 'n';\n\n        if (cell.cellStyle !== undefined && cell.cellStyle.name !== undefined) {\n          if (this.globalStyles.has(cell.cellStyle.name)) {\n            this.switchNumberFormat(this.globalStyles.get(cell.cellStyle.name).format, 'number');\n          }\n        }\n\n        break;\n\n      case 'string':\n        this.sharedStringCount++;\n        saveType = 's';\n        let sstvalue = this.processCellValue(value, cell);\n\n        if (!this.contains(this.sharedString, sstvalue)) {\n          this.sharedString.push(sstvalue);\n        }\n\n        value = this.sharedString.indexOf(sstvalue);\n        break;\n\n      default:\n        break;\n    }\n\n    cell.saveType = saveType;\n    cell.value = value;\n  }\n\n  parserImages(json, sheet) {\n    let imagesLength = json.length;\n    sheet.images = [];\n\n    for (let p = 0; p < imagesLength; p++) {\n      let image = this.parserImage(json[p]);\n      sheet.images.push(image);\n    }\n  }\n\n  parseFilters(json, sheet) {\n    sheet.autoFilters = new AutoFilters();\n    if (json.row !== null && json.row !== undefined) sheet.autoFilters.row = json.row;else throw new Error('Argument Null Exception: row null or empty');\n    if (json.lastRow !== null && json.lastRow !== undefined) sheet.autoFilters.lastRow = json.lastRow;else throw new Error('Argument Null Exception: lastRow cannot be null or empty');\n    if (json.column !== null && json.column !== undefined) sheet.autoFilters.column = json.column;else throw new Error('Argument Null Exception: column cannot be null or empty');\n    if (json.lastColumn !== null && json.row !== undefined) sheet.autoFilters.lastColumn = json.lastColumn;else throw new Error('Argument Null Exception: lastColumn cannot be null or empty');\n  }\n\n  parserImage(json) {\n    let image = new Image();\n\n    if (json.image !== null && json.image !== undefined) {\n      image.image = json.image;\n    }\n\n    if (json.row !== null && json.row !== undefined) {\n      image.row = json.row;\n    }\n\n    if (json.column !== null && json.column !== undefined) {\n      image.column = json.column;\n    }\n\n    if (json.lastRow !== null && json.lastRow !== undefined) {\n      image.lastRow = json.lastRow;\n    }\n\n    if (json.lastColumn !== null && json.lastColumn !== undefined) {\n      image.lastColumn = json.lastColumn;\n    }\n\n    if (json.width !== null && json.width !== undefined) {\n      image.width = json.width;\n    }\n\n    if (json.height !== null && json.height !== undefined) {\n      image.height = json.height;\n    }\n\n    if (json.horizontalFlip !== null && json.horizontalFlip !== undefined) {\n      image.horizontalFlip = json.horizontalFlip;\n    }\n\n    if (json.verticalFlip !== null && json.verticalFlip !== undefined) {\n      image.verticalFlip = json.verticalFlip;\n    }\n\n    if (json.rotation !== null && json.rotation !== undefined) {\n      image.rotation = json.rotation;\n    }\n\n    return image;\n  }\n\n  saveAsBlob(blobSaveType) {\n    switch (blobSaveType) {\n      case 'text/csv':\n        return new Promise((resolve, reject) => {\n          let obj = {};\n          obj.blobData = this.csvHelper.saveAsBlob();\n          resolve(obj);\n        });\n\n      default:\n        return new Promise((resolve, reject) => {\n          this.saveInternal();\n          this.mArchive.saveAsBlob().then(blob => {\n            let obj = {};\n            obj.blobData = new Blob([blob], {\n              type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n            });\n            resolve(obj);\n          });\n        });\n    }\n  }\n\n  save(fileName, proxyUrl) {\n    if (fileName === null || fileName === undefined || fileName === '') {\n      throw new Error('Argument Null Exception: fileName cannot be null or empty');\n    }\n\n    let xlsxMatch = fileName.match('.xlsx$');\n    let csvMatch = fileName.match('.csv$');\n\n    if (xlsxMatch !== null && xlsxMatch[0] === '.' + this.mSaveType) {\n      this.saveInternal();\n      this.mArchive.save(fileName).then(() => {\n        this.mArchive.destroy();\n      });\n    } else if (csvMatch !== null && csvMatch[0] === '.' + this.mSaveType) {\n      this.csvHelper.save(fileName);\n    } else {\n      throw Error('Save type and file extension is different.');\n    }\n  }\n\n  saveInternal() {\n    this.saveWorkbook();\n    this.saveWorksheets();\n    this.saveSharedString();\n    this.saveStyles();\n    this.saveApp(this.builtInProperties);\n    this.saveCore(this.builtInProperties);\n    this.saveContentType();\n    this.saveTopLevelRelation();\n    this.saveWorkbookRelation();\n  }\n\n  saveWorkbook() {\n    /* tslint:disable-next-line:max-line-length */\n    let workbookTemp = '<?xml version=\"1.0\" encoding=\"utf-8\"?><workbook xmlns:r = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns= \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><workbookPr codeName=\"ThisWorkbook\" defaultThemeVersion= \"153222\"/><bookViews><workbookView activeTab=\"0\"/></bookViews>';\n    let sheets = '<sheets>';\n    let length = this.worksheets.length;\n\n    for (let i = 0; i < length; i++) {\n      /* tslint:disable-next-line:max-line-length */\n      let sheetName = this.worksheets[i].name;\n      sheetName = sheetName.replace(\"&\", \"&amp;\");\n      sheetName = sheetName.replace(\"<\", \"&lt;\");\n      sheetName = sheetName.replace(\">\", \"&gt;\");\n      sheetName = sheetName.replace(\"\\\"\", \"&quot;\");\n      sheets += '<sheet name=\"' + sheetName + '\" sheetId=\"' + (i + 1).toString() + '\" r:id =\"rId' + (i + 1).toString() + '\" />';\n    }\n\n    sheets += '</sheets>';\n    workbookTemp += sheets;\n\n    if (this.printTitles.size > 0) {\n      let printTitle = '<definedNames>';\n      this.printTitles.forEach((value, key) => {\n        printTitle += '<definedName name=\"_xlnm.Print_Titles\" localSheetId=\"' + key + '\">' + value + '</definedName>';\n      });\n      printTitle += '</definedNames>';\n      workbookTemp += printTitle;\n    }\n\n    this.addToArchive(workbookTemp + '</workbook>', 'xl/workbook.xml');\n  }\n\n  saveWorksheets() {\n    let length = this.worksheets.length;\n\n    for (let i = 0; i < length; i++) {\n      this.saveWorksheet(this.worksheets[i], i);\n    }\n  }\n\n  saveWorksheet(sheet, index) {\n    let sheetBlob = new BlobHelper();\n    /* tslint:disable-next-line:max-line-length */\n\n    let sheetString = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><worksheet xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">';\n\n    if (!sheet.isSummaryRowBelow) {\n      sheetString += '<sheetPr>' + '<outlinePr ' + 'summaryBelow=\"0\" >' + '</outlinePr>' + '</sheetPr>';\n    } else {\n      sheetString += '<sheetPr />';\n    }\n\n    sheetString += this.saveSheetView(sheet);\n\n    if (sheet.columns !== undefined) {\n      let colString = '<cols>';\n\n      for (let column of sheet.columns) {\n        /* tslint:disable-next-line:max-line-length */\n        if (column.width !== undefined) {\n          colString += '<col min=\"' + column.index + '\" max=\"' + column.index + '\" width=\"' + this.pixelsToColumnWidth(column.width) + '\" customWidth=\"1\" />';\n        } else {\n          colString += '<col min=\"' + column.index + '\" max=\"' + column.index + '\" width=\"' + '8.43' + '\" customWidth=\"1\" />';\n        }\n      }\n\n      sheetString += colString + '</cols>';\n    }\n\n    sheetString += '<sheetData>';\n    sheetBlob.append(sheetString);\n    sheetString = '';\n\n    if (sheet.rows !== undefined) {\n      for (let row of sheet.rows) {\n        let rowString = '<row r=\"' + row.index + '\" ';\n\n        if (!isNullOrUndefined(row.spans)) {\n          rowString += 'spans=\"' + row.spans + '\" ';\n        }\n\n        if (row.height !== undefined) {\n          rowString += 'ht=\"' + this.pixelsToRowHeight(row.height) + '\" customHeight=\"1\" ';\n        }\n\n        if (row.grouping !== undefined) {\n          if (row.grouping.isHidden) {\n            rowString += 'hidden=\"1\" ';\n          }\n\n          if (row.grouping.outlineLevel !== undefined) {\n            rowString += 'outlineLevel=\"' + row.grouping.outlineLevel + '\" ';\n          }\n\n          if (row.grouping.isCollapsed) {\n            rowString += 'collapsed=\"1\" ';\n          }\n        }\n\n        rowString += '>';\n\n        for (let cell of row.cells) {\n          if (cell !== undefined && (cell.value !== undefined || cell.cellStyle !== undefined)) {\n            rowString += '<c r=\"' + cell.refName + '\" ';\n\n            if (cell.saveType !== undefined) {\n              rowString += 't=\"' + cell.saveType + '\" ';\n            }\n\n            if (cell.styleIndex !== undefined) {\n              rowString += 's=\"' + cell.styleIndex + '\" ';\n            }\n\n            rowString += ' >';\n\n            if (cell.formula !== undefined) {\n              rowString += '<f>' + cell.formula + '</f>';\n            }\n\n            if (cell.value !== undefined) {\n              rowString += '<v>' + cell.value + '</v></c>';\n            } else {\n              rowString += '</c>';\n            }\n          }\n        }\n\n        rowString += '</row>';\n        sheetBlob.append(rowString);\n      }\n    }\n\n    sheetString += '</sheetData>';\n    /* tslint:disable-next-line:max-line-length */\n\n    if (sheet.autoFilters !== null && sheet.autoFilters !== undefined) sheetString += '<autoFilter ref=\"' + this.getCellName(sheet.autoFilters.row, sheet.autoFilters.column) + ':' + this.getCellName(sheet.autoFilters.lastRow, sheet.autoFilters.lastColumn) + '\"/>';\n\n    if (sheet.mergeCells.length > 0) {\n      sheetString += '<mergeCells count=\"' + sheet.mergeCells.length + '\">';\n\n      for (let mCell of sheet.mergeCells) {\n        sheetString += '<mergeCell ref=\"' + mCell.ref + '\" />';\n      }\n\n      sheetString += '</mergeCells>';\n    }\n\n    if (sheet.hyperLinks.length > 0) {\n      sheetString += '<hyperlinks>';\n\n      for (let hLink of sheet.hyperLinks) {\n        sheetString += '<hyperlink ref=\"' + hLink.ref + '\" r:id=\"rId' + hLink.rId + '\" />';\n      }\n\n      sheetString += '</hyperlinks>';\n    }\n    /* tslint:disable-next-line:max-line-length */\n\n\n    sheetString += '<pageMargins left=\"0.75\" right=\"0.75\" top=\"1\" bottom=\"1\" header=\"0.5\" footer=\"0.5\" /><headerFooter scaleWithDoc=\"1\" alignWithMargins=\"0\" differentFirst=\"0\" differentOddEven=\"0\" />';\n\n    if (sheet.images != undefined && sheet.images.length > 0) {\n      this.drawingCount++;\n      this.saveDrawings(sheet, sheet.index);\n      sheetString += '<drawing r:id=\"rId' + (sheet.hyperLinks.length + 1) + '\"/>';\n    }\n\n    this.addToArchive(this.saveSheetRelations(sheet), 'xl/worksheets/_rels/sheet' + sheet.index + '.xml.rels');\n    sheetBlob.append(sheetString + '</worksheet>');\n    this.addToArchive(sheetBlob.getBlob(), 'xl/worksheets' + '/sheet' + (index + 1) + '.xml');\n  }\n\n  saveDrawings(sheet, index) {\n    let drawings = new BlobHelper();\n    /* tslint:disable-next-line:max-line-length */\n\n    let sheetDrawingString = '<xdr:wsDr xmlns:xdr=\"http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing\" xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">';\n\n    if (sheet.images !== undefined) {\n      let imgId = 0;\n\n      for (let pic of sheet.images) {\n        if (pic.height !== undefined && pic.width !== undefined) {\n          this.updatelastRowOffset(sheet, pic);\n          this.updatelastColumnOffSet(sheet, pic);\n        } else if (pic.lastRow !== undefined && pic.lastColumn !== undefined) {\n          pic.lastRowOffset = 0;\n          pic.lastColOffset = 0;\n        }\n\n        imgId++;\n        sheetDrawingString += '<xdr:twoCellAnchor editAs=\"oneCell\">';\n        sheetDrawingString += '<xdr:from><xdr:col>'; //col\n\n        sheetDrawingString += pic.column - 1;\n        sheetDrawingString += '</xdr:col><xdr:colOff>'; //colOff\n\n        sheetDrawingString += 0;\n        sheetDrawingString += '</xdr:colOff><xdr:row>'; //row\n\n        sheetDrawingString += pic.row - 1;\n        sheetDrawingString += '</xdr:row><xdr:rowOff>'; //rowOff\n\n        sheetDrawingString += 0;\n        sheetDrawingString += '</xdr:rowOff></xdr:from>';\n        sheetDrawingString += '<xdr:to><xdr:col>'; //col\n\n        sheetDrawingString += pic.lastColumn;\n        sheetDrawingString += '</xdr:col><xdr:colOff>'; //colOff\n\n        sheetDrawingString += pic.lastColOffset;\n        sheetDrawingString += '</xdr:colOff><xdr:row>'; //row\n\n        sheetDrawingString += pic.lastRow;\n        sheetDrawingString += '</xdr:row><xdr:rowOff>'; //rowOff\n\n        sheetDrawingString += pic.lastRowOffset;\n        sheetDrawingString += '</xdr:rowOff></xdr:to>';\n        sheetDrawingString += '<xdr:pic>';\n        sheetDrawingString += '<xdr:nvPicPr>';\n        sheetDrawingString += '<xdr:cNvPr id=\"' + imgId + '\" name=\"Picture ' + imgId + '\"> </xdr:cNvPr>';\n        sheetDrawingString += '<xdr:cNvPicPr><a:picLocks noChangeAspect=\"1\"/></xdr:cNvPicPr> </xdr:nvPicPr>';\n        sheetDrawingString += '<xdr:blipFill>';\n        /* tslint:disable-next-line:max-line-length */\n\n        sheetDrawingString += '<a:blip xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:embed=\"rId' + imgId + '\" cstate=\"print\">';\n        sheetDrawingString += '</a:blip><a:stretch><a:fillRect /></a:stretch></xdr:blipFill>';\n        sheetDrawingString += '<xdr:spPr>';\n        sheetDrawingString += '<a:xfrm';\n\n        if (pic.rotation != undefined && pic.rotation <= 3600 && pic.rotation >= -3600) {\n          sheetDrawingString += ' rot=\"' + pic.rotation * 60000 + '\"';\n        }\n\n        if (pic.verticalFlip != undefined && pic.verticalFlip != false) {\n          sheetDrawingString += ' flipV=\"1\"';\n        }\n\n        if (pic.horizontalFlip != undefined && pic.horizontalFlip != false) {\n          sheetDrawingString += ' flipH=\"1\"';\n        }\n\n        sheetDrawingString += '/>';\n        sheetDrawingString += '<a:prstGeom prst=\"rect\"><a:avLst /></a:prstGeom></xdr:spPr>';\n        sheetDrawingString += '</xdr:pic><xdr:clientData /></xdr:twoCellAnchor>';\n        let imageData = this.convertBase64toImage(pic.image);\n        this.imageCount += 1;\n        this.addToArchive(imageData, 'xl/media/image' + this.imageCount + '.png');\n      }\n\n      drawings.append(sheetDrawingString);\n      drawings.append('</xdr:wsDr>');\n      this.saveDrawingRelations(sheet);\n      this.addToArchive(drawings.getBlob(), 'xl/drawings/drawing' + this.drawingCount + '.xml');\n    }\n  }\n\n  updatelastRowOffset(sheet, picture) {\n    let iCurHeight = picture.height;\n    let iCurRow = picture.row;\n    let iCurOffset = 0;\n\n    while (iCurHeight >= 0) {\n      let iRowHeight = 0;\n      if (sheet.rows !== undefined && sheet.rows[iCurRow - 1] !== undefined) iRowHeight = this.convertToPixels(sheet.rows[iCurRow - 1].height === undefined ? 15 : sheet.rows[iCurRow - 1].height);else iRowHeight = this.convertToPixels(15);\n      let iSpaceInCell = iRowHeight - iCurOffset * iRowHeight / 256;\n\n      if (iSpaceInCell > iCurHeight) {\n        picture.lastRow = iCurRow;\n        picture.lastRowOffset = iCurOffset + iCurHeight * 256 / iRowHeight;\n        let rowHiddenHeight = 0;\n        if (sheet.rows !== undefined && sheet.rows[iCurRow - 1] !== undefined) rowHiddenHeight = this.convertToPixels(sheet.rows[iCurRow - 1].height === undefined ? 15 : sheet.rows[iCurRow - 1].height);else rowHiddenHeight = this.convertToPixels(15);\n        picture.lastRowOffset = rowHiddenHeight * picture.lastRowOffset / 256;\n        picture.lastRowOffset = Math.round(picture.lastRowOffset / this.unitsProportions[7]);\n        break;\n      } else {\n        iCurHeight -= iSpaceInCell;\n        iCurRow++;\n        iCurOffset = 0;\n      }\n    }\n  }\n\n  updatelastColumnOffSet(sheet, picture) {\n    let iCurWidth = picture.width;\n    let iCurCol = picture.column;\n    let iCurOffset = 0;\n\n    while (iCurWidth >= 0) {\n      let iColWidth = 0;\n      if (sheet.columns !== undefined && sheet.columns[iCurCol - 1] !== undefined) iColWidth = this.ColumnWidthToPixels(sheet.columns[iCurCol - 1].width === undefined ? 8.43 : sheet.columns[iCurCol - 1].width);else iColWidth = this.ColumnWidthToPixels(8.43);\n      let iSpaceInCell = iColWidth - iCurOffset * iColWidth / 1024;\n\n      if (iSpaceInCell > iCurWidth) {\n        picture.lastColumn = iCurCol;\n        picture.lastColOffset = iCurOffset + iCurWidth * 1024 / iColWidth;\n        let colHiddenWidth = 0;\n        if (sheet.columns !== undefined && sheet.columns[iCurCol - 1] !== undefined) colHiddenWidth = this.ColumnWidthToPixels(sheet.columns[iCurCol - 1].width === undefined ? 8.43 : sheet.columns[iCurCol].width);else colHiddenWidth = this.ColumnWidthToPixels(8.43);\n        picture.lastColOffset = colHiddenWidth * picture.lastColOffset / 1024;\n        picture.lastColOffset = Math.round(picture.lastColOffset / this.unitsProportions[7]);\n        break;\n      } else {\n        iCurWidth -= iSpaceInCell;\n        iCurCol++;\n        iCurOffset = 0;\n      }\n    }\n  }\n\n  convertToPixels(value) {\n    return value * this.unitsProportions[6];\n  }\n\n  convertBase64toImage(img) {\n    const byteStr = window.atob(img);\n    const buffer = new ArrayBuffer(byteStr.length);\n    const data = new Uint8Array(buffer);\n\n    for (let i = 0; i < byteStr.length; i++) {\n      data[i] = byteStr.charCodeAt(i);\n    }\n\n    const blob = new Blob([data], {\n      type: 'image/png'\n    });\n    return blob;\n  }\n\n  saveDrawingRelations(sheet) {\n    /* tslint:disable-next-line:max-line-length */\n    let drawingRelation = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">';\n    let length = sheet.images.length;\n    let id = this.imageCount - sheet.images.length;\n\n    for (let i = 1; i <= length; i++) {\n      id++;\n      /* tslint:disable-next-line:max-line-length */\n\n      drawingRelation += '<Relationship Id=\"rId' + i + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\" Target=\"../media/image' + id + '.png\" />';\n    }\n\n    this.addToArchive(drawingRelation + '</Relationships>', 'xl/drawings/_rels/drawing' + this.drawingCount + '.xml.rels');\n  }\n\n  pixelsToColumnWidth(pixels) {\n    let dDigitWidth = 7;\n    let val = pixels > dDigitWidth + 5 ? this.trunc((pixels - 5) / dDigitWidth * 100 + 0.5) / 100 : pixels / (dDigitWidth + 5);\n    return val > 1 ? (val * dDigitWidth + 5) / dDigitWidth * 256.0 / 256.0 : val * (dDigitWidth + 5) / dDigitWidth * 256.0 / 256.0;\n  }\n\n  ColumnWidthToPixels(val) {\n    let dDigitWidth = 7;\n    let fileWidth = val > 1 ? (val * dDigitWidth + 5) / dDigitWidth * 256.0 / 256.0 : val * (dDigitWidth + 5) / dDigitWidth * 256.0 / 256.0;\n    return this.trunc((256 * fileWidth + this.trunc(128 / dDigitWidth)) / 256 * dDigitWidth);\n  }\n\n  trunc(x) {\n    let n = x - x % 1;\n    return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;\n  }\n\n  pixelsToRowHeight(pixels) {\n    return pixels * this.unitsProportions[5] / this.unitsProportions[6];\n  }\n\n  saveSheetRelations(sheet) {\n    /* tslint:disable-next-line:max-line-length */\n    let relStr = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">';\n\n    for (let hLink of sheet.hyperLinks) {\n      /* tslint:disable-next-line:max-line-length */\n      relStr += '<Relationship Id=\"rId' + hLink.rId + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\" Target=\"' + this.processString(hLink.target) + '\" TargetMode=\"External\" />';\n    }\n\n    if (sheet.images != undefined && sheet.images.length > 0) {\n      /* tslint:disable-next-line:max-line-length */\n      relStr += '<Relationship Id=\"rId' + (sheet.hyperLinks.length + 1) + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing\" Target=\"../drawings/drawing' + this.drawingCount + '.xml\" />';\n    }\n\n    relStr += '</Relationships>';\n    return relStr;\n  }\n\n  saveSheetView(sheet) {\n    let paneString = '<sheetViews><sheetView workbookViewId=\"0\" ';\n\n    if (sheet.enableRtl === true) {\n      paneString += 'rightToLeft=\"1\"';\n    }\n\n    if (sheet.showGridLines === false) {\n      paneString += 'showGridLines=\"0\" >';\n    } else {\n      paneString += '>';\n    }\n\n    if (sheet.freezePanes !== undefined) {\n      paneString += '<pane state=\"frozen\"' + ' topLeftCell=\"' + sheet.freezePanes.leftCell + '\" ';\n\n      if (sheet.freezePanes.row !== 0) {\n        paneString += 'ySplit=\"' + sheet.freezePanes.row + '\" ';\n      }\n\n      if (sheet.freezePanes.column !== 0) {\n        paneString += 'xSplit=\"' + sheet.freezePanes.column + '\" ';\n      }\n\n      paneString += '/>';\n    }\n\n    paneString += '</sheetView></sheetViews > ';\n    return paneString;\n  }\n\n  saveSharedString() {\n    let length = this.sharedString.length;\n\n    if (length > 0) {\n      /* tslint:disable-next-line:max-line-length */\n      let sstStart = '<?xml version=\"1.0\" encoding=\"utf-8\"?><sst uniqueCount=\"' + length + '\" count=\"' + this.sharedStringCount + '\" xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">';\n      let si = '';\n\n      for (let i = 0; i < length; i++) {\n        if (this.sharedString[i].indexOf('<r>') !== 0) {\n          si += '<si><t>';\n          si += this.processString(this.sharedString[i]);\n          si += '</t></si>';\n        } else {\n          si += '<si>';\n          si += this.sharedString[i];\n          si += '</si>';\n        }\n      }\n\n      si += '</sst>';\n      this.addToArchive(sstStart + si, 'xl/sharedStrings.xml');\n    }\n  }\n\n  processString(value) {\n    if (value.indexOf('&') !== -1) {\n      value = value.replace(/&/g, '&amp;');\n    }\n\n    if (value.indexOf('<') !== -1) {\n      value = value.replace(/</g, '&lt;');\n    }\n\n    if (value.indexOf('>') !== -1) {\n      value = value.replace(/>/g, '&gt;');\n    }\n\n    return value;\n  }\n\n  saveStyles() {\n    this.updateCellXfsStyleXfs();\n    /* tslint:disable-next-line:max-line-length */\n\n    let styleTemp = '<?xml version=\"1.0\" encoding=\"utf-8\"?><styleSheet xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">';\n    styleTemp += this.saveNumberFormats();\n    styleTemp += this.saveFonts();\n    styleTemp += this.saveFills();\n    styleTemp += this.saveBorders();\n    styleTemp += this.saveCellStyleXfs();\n    styleTemp += this.saveCellXfs();\n    styleTemp += this.saveCellStyles();\n    this.addToArchive(styleTemp + '</styleSheet>', 'xl/styles.xml');\n  }\n\n  updateCellXfsStyleXfs() {\n    for (let style of this.mStyles) {\n      let cellXfs = undefined;\n\n      if (style.isGlobalStyle) {\n        cellXfs = new CellStyleXfs();\n        cellXfs.xfId = style.index - 1;\n      } else {\n        cellXfs = new CellXfs();\n        cellXfs.xfId = 0;\n      } //Add font\n\n\n      let compareFontResult = this.isNewFont(style);\n\n      if (!compareFontResult.result) {\n        let font = new Font();\n        font.b = style.bold;\n        font.i = style.italic;\n        font.name = style.fontName;\n        font.sz = style.fontSize;\n        font.u = style.underline;\n        font.color = 'FF' + style.fontColor.replace('#', '');\n        this.mFonts.push(font);\n        cellXfs.fontId = this.mFonts.length - 1;\n      } else {\n        cellXfs.fontId = compareFontResult.index;\n      } //Add fill\n\n\n      if (style.backColor !== 'none') {\n        let backColor = 'FF' + style.backColor.replace('#', '');\n\n        if (this.mFills.has(backColor)) {\n          let fillId = this.mFills.get(backColor);\n          cellXfs.fillId = fillId;\n        } else {\n          let fillId = this.mFills.size + 2;\n          this.mFills.set(backColor, fillId);\n          cellXfs.fillId = fillId;\n        }\n      } else {\n        cellXfs.fillId = 0;\n      } //Add border            \n\n\n      if (!this.isNewBorder(style)) {\n        this.mBorders.push(style.borders);\n        cellXfs.borderId = this.mBorders.length;\n      } else {\n        cellXfs.borderId = 0;\n      } //Add Number Format            \n\n\n      if (style.numberFormat !== 'GENERAL') {\n        if (this.mNumFmt.has(style.numberFormat)) {\n          let numFmt = this.mNumFmt.get(style.numberFormat);\n          cellXfs.numFmtId = numFmt.numFmtId;\n        } else {\n          let id = this.mNumFmt.size + 164;\n          this.mNumFmt.set(style.numberFormat, new NumFmt(id, style.numberFormat));\n          cellXfs.numFmtId = id;\n        }\n      } else {\n        if (style.numberFormat === 'GENERAL' && style.numFmtId === 14) {\n          cellXfs.numFmtId = 14;\n        } else {\n          cellXfs.numFmtId = 0;\n        }\n      } //Add alignment            \n\n\n      if (!style.isGlobalStyle) {\n        cellXfs.applyAlignment = 1;\n      }\n\n      cellXfs.alignment = new Alignment();\n      cellXfs.alignment.indent = style.indent;\n      cellXfs.alignment.horizontal = style.hAlign;\n      cellXfs.alignment.vertical = style.vAlign;\n      cellXfs.alignment.wrapText = style.wrapText ? 1 : 0;\n      cellXfs.alignment.rotation = style.rotation;\n\n      if (style.isGlobalStyle) {\n        this.mCellStyleXfs.push(cellXfs);\n        this.mCellXfs.push(cellXfs);\n      } else {\n        //Add cellxfs\n        this.mCellXfs.push(cellXfs);\n      }\n    }\n  }\n\n  saveNumberFormats() {\n    if (this.mNumFmt.size >= 1) {\n      let numFmtStyle = '<numFmts count=\"' + this.mNumFmt.size + '\">';\n      this.mNumFmt.forEach((value, key) => {\n        numFmtStyle += '<numFmt numFmtId=\"' + value.numFmtId + '\" formatCode=\"' + value.formatCode.replace(/\"/g, '&quot;') + '\" />';\n      });\n      return numFmtStyle += '</numFmts>';\n    } else {\n      return '';\n    }\n  }\n\n  saveFonts() {\n    /* tslint:disable-next-line:max-line-length */\n    let fontStyle = '<fonts count=\"' + this.mFonts.length + '\">';\n\n    if (this.mFonts.length >= 1) {\n      for (let font of this.mFonts) {\n        fontStyle += '<font>';\n\n        if (font.b) {\n          fontStyle += '<b />';\n        }\n\n        if (font.i) {\n          fontStyle += '<i />';\n        }\n\n        if (font.u) {\n          fontStyle += '<u />';\n        }\n\n        fontStyle += '<sz val=\"' + font.sz + '\" />';\n        fontStyle += '<color rgb=\"' + font.color + '\" />';\n        fontStyle += '<name val=\"' + font.name + '\" /></font>';\n      }\n    }\n\n    return fontStyle + '</fonts>';\n  }\n\n  saveFills() {\n    /* tslint:disable-next-line:max-line-length */\n    let fillsStyle = '<fills count=\"' + (this.mFills.size + 2) + '\"><fill><patternFill patternType=\"none\"></patternFill></fill><fill><patternFill patternType=\"gray125\"></patternFill></fill>';\n\n    if (this.mFills.size >= 1) {\n      this.mFills.forEach((value, key) => {\n        /* tslint:disable-next-line:max-line-length */\n        fillsStyle += '<fill><patternFill patternType=\"solid\"><fgColor rgb=\"' + key + '\" /><bgColor rgb=\"FFFFFFFF\" /></patternFill></fill>';\n      });\n    }\n\n    return fillsStyle + '</fills>';\n  }\n\n  saveBorders() {\n    /* tslint:disable-next-line:max-line-length */\n    let bordersStyle = '<borders count=\"' + (this.mBorders.length + 1) + '\"><border><left /><right /><top /><bottom /><diagonal /></border>';\n\n    if (this.mBorders.length >= 1) {\n      for (let borders of this.mBorders) {\n        if (this.isAllBorder(borders)) {\n          let color = borders.all.color.replace('#', '');\n          let lineStyle = borders.all.lineStyle;\n          /* tslint:disable-next-line:max-line-length */\n\n          bordersStyle += '<border><left style=\"' + lineStyle + '\"><color rgb=\"FF' + color + '\" /></left><right style=\"' + lineStyle + '\"><color rgb=\"FF' + color + '\" /></right><top style=\"' + lineStyle + '\"><color rgb=\"FF' + color + '\" /></top><bottom style=\"' + lineStyle + '\"><color rgb=\"FF' + color + '\" /></bottom></border>';\n        } else {\n          /* tslint:disable-next-line:max-line-length */\n          bordersStyle += '<border><left style=\"' + borders.left.lineStyle + '\"><color rgb=\"FF' + borders.left.color.replace('#', '') + '\" /></left><right style=\"' + borders.right.lineStyle + '\"><color rgb=\"FF' + borders.right.color.replace('#', '') + '\" /></right><top style=\"' + borders.top.lineStyle + '\"><color rgb=\"FF' + borders.top.color.replace('#', '') + '\" /></top><bottom style=\"' + borders.bottom.lineStyle + '\"><color rgb=\"FF' + borders.bottom.color.replace('#', '') + '\" /></bottom></border>';\n        }\n      }\n    }\n\n    return bordersStyle + '</borders>';\n  }\n\n  saveCellStyles() {\n    let cellStyleString = '<cellStyles  count=\"' + this.cellStyles.size + '\">';\n    this.cellStyles.forEach((value, key) => {\n      cellStyleString += '<cellStyle name=\"' + key + '\" xfId=\"' + this.cellStyles.get(key).xfId + '\"';\n\n      if (key === 'Normal') {\n        cellStyleString += ' builtinId=\"0\"';\n      }\n\n      cellStyleString += ' />';\n    });\n    return cellStyleString += '</cellStyles>';\n  }\n\n  saveCellStyleXfs() {\n    /* tslint:disable-next-line:max-line-length */\n    let cellXfsStyle = '<cellStyleXfs count=\"' + (this.mCellStyleXfs.length + 1) + '\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" />';\n\n    if (this.mCellStyleXfs.length >= 1) {\n      for (let cellStyleXf of this.mCellStyleXfs) {\n        /* tslint:disable-next-line:max-line-length */\n        cellXfsStyle += '<xf numFmtId=\"' + cellStyleXf.numFmtId + '\" fontId=\"' + cellStyleXf.fontId + '\" fillId=\"' + cellStyleXf.fillId + '\" borderId=\"' + cellStyleXf.borderId + '\" ';\n\n        if (cellStyleXf.alignment !== undefined) {\n          cellXfsStyle += '>' + this.saveAlignment(cellStyleXf) + '</xf>';\n        } else {\n          cellXfsStyle += ' />';\n        }\n      }\n    }\n\n    return cellXfsStyle + '</cellStyleXfs>';\n  }\n\n  saveCellXfs() {\n    /* tslint:disable-next-line:max-line-length */\n    let cellXfsStyle = '<cellXfs count=\"' + (this.mCellXfs.length + 1) + '\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\" />';\n\n    if (this.mCellXfs.length >= 1) {\n      for (let cellXf of this.mCellXfs) {\n        /* tslint:disable-next-line:max-line-length */\n        cellXfsStyle += '<xf numFmtId=\"' + cellXf.numFmtId + '\" fontId=\"' + cellXf.fontId + '\" fillId=\"' + cellXf.fillId + '\" borderId=\"' + cellXf.borderId + '\" xfId=\"' + cellXf.xfId + '\" ';\n\n        if (cellXf.applyAlignment === 1) {\n          cellXfsStyle += 'applyAlignment=\"1\"';\n        }\n\n        cellXfsStyle += '>' + this.saveAlignment(cellXf) + '</xf>';\n      }\n    }\n\n    return cellXfsStyle + '</cellXfs>';\n  }\n\n  saveAlignment(cellXf) {\n    let alignString = '<alignment ';\n\n    if (cellXf.alignment.horizontal !== undefined) {\n      alignString += 'horizontal=\"' + cellXf.alignment.horizontal + '\" ';\n    }\n\n    if (cellXf.alignment.indent !== undefined && cellXf.alignment.indent !== 0) {\n      alignString += 'indent=\"' + cellXf.alignment.indent + '\" ';\n    } else if (cellXf.alignment.rotation !== undefined && cellXf.alignment.rotation !== 0) {\n      alignString += 'textRotation=\"' + cellXf.alignment.rotation + '\" ';\n    }\n\n    if (cellXf.alignment.vertical !== undefined) {\n      alignString += 'vertical=\"' + cellXf.alignment.vertical + '\" ';\n    }\n\n    alignString += 'wrapText=\"' + cellXf.alignment.wrapText + '\" />';\n    return alignString;\n  }\n\n  saveApp(builtInProperties) {\n    /* tslint:disable-next-line:max-line-length */\n    let appString = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\"><Application>Essential XlsIO</Application>';\n\n    if (builtInProperties !== undefined) {\n      if (builtInProperties.manager !== undefined) {\n        appString += '<Manager>' + builtInProperties.manager + '</Manager>';\n      }\n\n      if (builtInProperties.company !== undefined) {\n        appString += '<Company>' + builtInProperties.company + '</Company>';\n      }\n    }\n\n    this.addToArchive(appString + '</Properties>', 'docProps/app.xml');\n  }\n\n  saveCore(builtInProperties) {\n    let createdDate = new Date();\n    /* tslint:disable-next-line:max-line-length */\n\n    let coreString = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><cp:coreProperties xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\">';\n\n    if (this.builtInProperties !== undefined) {\n      if (builtInProperties.author !== undefined) {\n        coreString += '<dc:creator>' + builtInProperties.author + '</dc:creator>';\n      }\n\n      if (builtInProperties.subject !== undefined) {\n        coreString += '<dc:subject>' + builtInProperties.subject + '</dc:subject>';\n      }\n\n      if (builtInProperties.category !== undefined) {\n        coreString += '<cp:category>' + builtInProperties.category + '</cp:category>';\n      }\n\n      if (builtInProperties.comments !== undefined) {\n        coreString += '<dc:description>' + builtInProperties.comments + '</dc:description>';\n      }\n\n      if (builtInProperties.title !== undefined) {\n        coreString += '<dc:title>' + builtInProperties.title + '</dc:title>';\n      }\n\n      if (builtInProperties.tags !== undefined) {\n        coreString += '<cp:keywords>' + builtInProperties.tags + '</cp:keywords>';\n      }\n\n      if (builtInProperties.status !== undefined) {\n        coreString += '<cp:contentStatus>' + builtInProperties.status + '</cp:contentStatus>';\n      }\n\n      if (builtInProperties.createdDate !== undefined) {\n        /* tslint:disable-next-line:max-line-length */\n        coreString += '<dcterms:created xsi:type=\"dcterms:W3CDTF\">' + builtInProperties.createdDate.toISOString() + '</dcterms:created>';\n      } else {\n        coreString += '<dcterms:created xsi:type=\"dcterms:W3CDTF\">' + createdDate.toISOString() + '</dcterms:created>';\n      }\n\n      if (builtInProperties.modifiedDate !== undefined) {\n        /* tslint:disable-next-line:max-line-length */\n        coreString += '<dcterms:modified xsi:type=\"dcterms:W3CDTF\">' + builtInProperties.modifiedDate.toISOString() + '</dcterms:modified>';\n      } else {\n        coreString += '<dcterms:modified xsi:type=\"dcterms:W3CDTF\">' + createdDate.toISOString() + '</dcterms:modified>';\n      }\n    } else {\n      coreString += '<dcterms:created xsi:type=\"dcterms:W3CDTF\">' + createdDate.toISOString() + '</dcterms:created>';\n      coreString += '<dcterms:modified xsi:type=\"dcterms:W3CDTF\">' + createdDate.toISOString() + '</dcterms:modified>';\n    }\n    /* tslint:disable-next-line:max-line-length */\n\n\n    coreString += '</cp:coreProperties>';\n    this.addToArchive(coreString, 'docProps/core.xml');\n  }\n\n  saveTopLevelRelation() {\n    /* tslint:disable-next-line:max-line-length */\n    let topRelation = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\" /><Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\" /><Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\" /></Relationships>';\n    this.addToArchive(topRelation, '_rels/.rels');\n  }\n\n  saveWorkbookRelation() {\n    /* tslint:disable-next-line:max-line-length */\n    let wbRelation = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">';\n    let length = this.worksheets.length;\n    let count = 0;\n\n    for (let i = 0; i < length; i++, count++) {\n      /* tslint:disable-next-line:max-line-length */\n      wbRelation += '<Relationship Id=\"rId' + (i + 1).toString() + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet' + (i + 1).toString() + '.xml\" />';\n    }\n    /* tslint:disable-next-line:max-line-length */\n\n\n    wbRelation += '<Relationship Id=\"rId' + (++count).toString() + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\" />';\n\n    if (this.sharedStringCount > 0) {\n      /* tslint:disable-next-line:max-line-length */\n      wbRelation += '<Relationship Id=\"rId' + (++count).toString() + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\" Target=\"sharedStrings.xml\" />';\n    }\n\n    this.addToArchive(wbRelation + '</Relationships>', 'xl/_rels/workbook.xml.rels');\n  }\n\n  saveContentType() {\n    /* tslint:disable-next-line:max-line-length */\n    let contentTypeString = '<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?><Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\"><Default Extension=\"xml\" ContentType=\"application/xml\" /><Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" /><Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\" /><Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" /><Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\" /><Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\" />';\n    let sheetsOverride = '';\n    let length = this.worksheets.length;\n\n    for (let i = 0; i < length; i++) {\n      /* tslint:disable-next-line:max-line-length */\n      sheetsOverride += '<Override PartName=\"/xl/worksheets/sheet' + (i + 1).toString() + '.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" />';\n\n      if (this.worksheets[i].images != undefined && this.worksheets[i].images.length > 0) {\n        /* tslint:disable-next-line:max-line-length */\n        sheetsOverride += '<Override PartName=\"/xl/drawings/drawing' + (i + 1).toString() + '.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.drawing+xml\" />';\n      }\n    }\n\n    if (this.imageCount > 0) sheetsOverride += '<Default Extension=\"png\" ContentType=\"image/png\" />';\n\n    if (this.sharedStringCount > 0) {\n      /* tslint:disable-next-line:max-line-length */\n      contentTypeString += '<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\" />';\n    }\n\n    this.addToArchive(contentTypeString + sheetsOverride + '</Types>', '[Content_Types].xml');\n  }\n\n  addToArchive(xmlString, itemName) {\n    if (typeof xmlString === 'string') {\n      let blob = new Blob([xmlString], {\n        type: 'text/plain'\n      });\n      let archiveItem = new ZipArchiveItem(blob, itemName);\n      this.mArchive.addItem(archiveItem);\n    } else {\n      let archiveItem = new ZipArchiveItem(xmlString, itemName);\n      this.mArchive.addItem(archiveItem);\n    }\n  }\n\n  processMergeCells(cell, rowIndex, mergeCells) {\n    if (cell.rowSpan !== 0 || cell.colSpan !== 0) {\n      let mCell = new MergeCell();\n      mCell.x = cell.index;\n      mCell.width = cell.colSpan;\n      mCell.y = rowIndex;\n      mCell.height = cell.rowSpan;\n      let startCell = this.getCellName(mCell.y, mCell.x);\n      let endCell = this.getCellName(rowIndex + mCell.height, cell.index + mCell.width);\n      mCell.ref = startCell + ':' + endCell;\n      let mergedCell = mergeCells.add(mCell);\n      let start = {\n        x: mCell.x,\n        y: mCell.y\n      };\n      let end = {\n        x: cell.index + mCell.width,\n        y: rowIndex + mCell.height\n      };\n      this.updatedMergedCellStyles(start, end, cell);\n    }\n\n    return mergeCells;\n  }\n\n  updatedMergedCellStyles(sCell, eCell, cell) {\n    for (let x = sCell.x; x <= eCell.x; x++) {\n      for (let y = sCell.y; y <= eCell.y; y++) {\n        this.mergedCellsStyle.set(this.getCellName(y, x), {\n          x: x,\n          y: y,\n          styleIndex: cell.styleIndex\n        });\n      }\n    }\n  }\n  /**\n   * Returns the tick count corresponding to the given year, month, and day.\n   * @param year number value of year\n   * @param month number value of month\n   * @param day number value of day\n   */\n\n\n  dateToTicks(year, month, day) {\n    let ticksPerDay = 10000 * 1000 * 60 * 60 * 24;\n    let daysToMonth365 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];\n    let daysToMonth366 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];\n\n    if (year >= 1 && year <= 9999 && month >= 1 && month <= 12) {\n      let days = this.isLeapYear(year) ? daysToMonth366 : daysToMonth365;\n      let y = year - 1;\n      let n = y * 365 + (y / 4 | 0) - (y / 100 | 0) + (y / 400 | 0) + days[month - 1] + day - 1;\n      return n * ticksPerDay;\n    }\n\n    throw new Error('Not a valid date');\n  }\n  /**\n   * Return the tick count corresponding to the given hour, minute, second.\n   * @param hour number value of hour\n   * @param minute number value if minute\n   * @param second number value of second\n   */\n\n\n  timeToTicks(hour, minute, second) {\n    if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60) {\n      let totalSeconds = hour * 3600 + minute * 60 + second;\n      return totalSeconds * 10000 * 1000;\n    }\n\n    throw new Error('Not valid time');\n  }\n  /**\n   * Checks if given year is a leap year.\n   * @param year Year value.\n   */\n\n\n  isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n  }\n  /**\n   * Converts `DateTime` to the equivalent OLE Automation date.\n   */\n\n\n  toOADate(date) {\n    let ticks = 0;\n    /* tslint:disable-next-line:max-line-length */\n\n    ticks = this.dateToTicks(date.getFullYear(), date.getMonth() + 1, date.getDate()) + this.timeToTicks(date.getHours(), date.getMinutes(), date.getSeconds());\n\n    if (ticks === 0) {\n      return 0.0;\n    }\n\n    let ticksPerDay = 10000 * 1000 * 60 * 60 * 24;\n    let daysTo1899 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 4 + ((365 * 4 + 1) * 25 - 1) * 3 - 367;\n    let doubleDateOffset = daysTo1899 * ticksPerDay;\n    let oaDateMinAsTicks = ((365 * 4 + 1) * 25 - 1 - 365) * ticksPerDay;\n\n    if (ticks < oaDateMinAsTicks) {\n      throw new Error('Arg_OleAutDateInvalid');\n    }\n\n    let millisPerDay = 1000 * 60 * 60 * 24;\n    return (ticks - doubleDateOffset) / 10000 / millisPerDay;\n  }\n\n}\n/**\n * BuiltInProperties Class\n * @private\n */\n\n\nclass BuiltInProperties {}\n/**\n * index class\n */\n\n\nexport { CellStyle, Font, CellXfs, Alignment, CellStyleXfs, CellStyles, NumFmt, Border, Borders, Cell, Cells, Column, Row, Rows, Workbook, BuiltInProperties, Worksheet, HyperLink, Grouping, FreezePane, MergeCell, MergeCells, Worksheets, CsvHelper, ValueFormatter, BlobHelper }; //# sourceMappingURL=ej2-excel-export.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}