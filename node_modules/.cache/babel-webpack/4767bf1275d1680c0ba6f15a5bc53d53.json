{"ast":null,"code":"import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\n\nconst ARR_LITERAL_CODES = new Int16Array(286);\nconst ARR_LITERAL_LENGTHS = new Uint8Array(286);\nconst ARR_DISTANCE_CODES = new Int16Array(30);\nconst ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nlet CompressedStreamWriter = /*#__PURE__*/(() => {\n  class CompressedStreamWriter {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    constructor(noWrap) {\n      this.pendingBuffer = new Uint8Array(1 << 16);\n      this.pendingBufLength = 0;\n      this.pendingBufCache = 0;\n      this.pendingBufBitsInCache = 0;\n      this.bufferPosition = 0;\n      this.extraBits = 0;\n      this.currentHash = 0;\n      this.matchStart = 0;\n      this.matchLength = 0;\n      this.matchPrevAvail = false;\n      this.blockStart = 0;\n      this.stringStart = 0;\n      this.lookAhead = 0;\n      this.totalBytesIn = 0;\n      this.inputOffset = 0;\n      this.inputEnd = 0;\n      this.windowSize = 1 << 15;\n      this.windowMask = this.windowSize - 1;\n      this.hashSize = 1 << 15;\n      this.hashMask = this.hashSize - 1;\n      this.hashShift = Math.floor((15 + 3 - 1) / 3);\n      this.maxDist = this.windowSize - 262;\n      this.checkSum = 1;\n      this.noWrap = false;\n\n      if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n        CompressedStreamWriter.initHuffmanTree();\n        CompressedStreamWriter.isHuffmanTreeInitiated = true;\n      }\n\n      this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n      this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n      this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n      this.arrDistances = new Uint16Array(1 << 14);\n      this.arrLiterals = new Uint8Array(1 << 14);\n      this.stream = [];\n      this.dataWindow = new Uint8Array(2 * this.windowSize);\n      this.hashHead = new Int16Array(this.hashSize);\n      this.hashPrevious = new Int16Array(this.windowSize);\n      this.blockStart = this.stringStart = 1;\n      this.noWrap = noWrap;\n\n      if (!noWrap) {\n        this.writeZLibHeader();\n      }\n    }\n    /**\n     * get compressed data\n     */\n\n\n    get compressedData() {\n      return this.stream;\n    }\n\n    get getCompressedString() {\n      let compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (let i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    }\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n\n\n    write(data, offset, length) {\n      if (data === undefined || data === null) {\n        throw new Error('ArgumentException: data cannot null or undefined');\n      }\n\n      let end = offset + length;\n\n      if (0 > offset || offset > end || end > data.length) {\n        throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n      }\n\n      if (typeof data === 'string') {\n        let encode = new Encoding(false);\n        encode.type = 'Utf8';\n        data = new Uint8Array(encode.getBytes(data, 0, data.length));\n        end = offset + data.length;\n      }\n\n      this.inputBuffer = data;\n      this.inputOffset = offset;\n      this.inputEnd = end;\n\n      if (!this.noWrap) {\n        this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n      }\n\n      while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n        this.pendingBufferFlush();\n        this.compressData(false);\n      }\n    }\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n\n\n    writeZLibHeader() {\n      /* Initialize header.*/\n      let headerDate = 8 + (7 << 4) << 8;\n      /* Save compression level.*/\n\n      headerDate |= (5 >> 2 & 3) << 6;\n      /* Align header.*/\n\n      headerDate += 31 - headerDate % 31;\n      /* Write header to stream.*/\n\n      this.pendingBufferWriteShortBytes(headerDate);\n    }\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n\n\n    pendingBufferWriteShortBytes(s) {\n      this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n      this.pendingBuffer[this.pendingBufLength++] = s;\n    }\n\n    compressData(finish) {\n      let success;\n\n      do {\n        this.fillWindow();\n        let canFlush = finish && this.inputEnd === this.inputOffset;\n        success = this.compressSlow(canFlush, finish);\n      } while (this.pendingBufLength === 0 && success);\n\n      return success;\n    }\n\n    compressSlow(flush, finish) {\n      if (this.lookAhead < 262 && !flush) {\n        return false;\n      }\n\n      while (this.lookAhead >= 262 || flush) {\n        if (this.lookAhead === 0) {\n          return this.lookAheadCompleted(finish);\n        }\n\n        if (this.stringStart >= 2 * this.windowSize - 262) {\n          this.slideWindow();\n        }\n\n        let prevMatch = this.matchStart;\n        let prevLen = this.matchLength;\n\n        if (this.lookAhead >= 3) {\n          this.discardMatch();\n        }\n\n        if (prevLen >= 3 && this.matchLength <= prevLen) {\n          prevLen = this.matchPreviousBest(prevMatch, prevLen);\n        } else {\n          this.matchPreviousAvailable();\n        }\n\n        if (this.bufferPosition >= 1 << 14) {\n          return this.huffmanIsFull(finish);\n        }\n      }\n\n      return true;\n    }\n\n    discardMatch() {\n      let hashHead = this.insertString();\n\n      if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n        if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n          this.matchLength = 3 - 1;\n        }\n      }\n    }\n\n    matchPreviousAvailable() {\n      if (this.matchPrevAvail) {\n        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n      }\n\n      this.matchPrevAvail = true;\n      this.stringStart++;\n      this.lookAhead--;\n    }\n\n    matchPreviousBest(prevMatch, prevLen) {\n      this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n      prevLen -= 2;\n\n      do {\n        this.stringStart++;\n        this.lookAhead--;\n\n        if (this.lookAhead >= 3) {\n          this.insertString();\n        }\n      } while (--prevLen > 0);\n\n      this.stringStart++;\n      this.lookAhead--;\n      this.matchPrevAvail = false;\n      this.matchLength = 3 - 1;\n      return prevLen;\n    }\n\n    lookAheadCompleted(finish) {\n      if (this.matchPrevAvail) {\n        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n      }\n\n      this.matchPrevAvail = false;\n      this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n      this.blockStart = this.stringStart;\n      return false;\n    }\n\n    huffmanIsFull(finish) {\n      let len = this.stringStart - this.blockStart;\n\n      if (this.matchPrevAvail) {\n        len--;\n      }\n\n      let lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n      this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n      this.blockStart += len;\n      return !lastBlock;\n    }\n\n    fillWindow() {\n      if (this.stringStart >= this.windowSize + this.maxDist) {\n        this.slideWindow();\n      }\n\n      while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n        let more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n        if (more > this.inputEnd - this.inputOffset) {\n          more = this.inputEnd - this.inputOffset;\n        }\n\n        this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n        this.inputOffset += more;\n        this.totalBytesIn += more;\n        this.lookAhead += more;\n      }\n\n      if (this.lookAhead >= 3) {\n        this.updateHash();\n      }\n    }\n\n    slideWindow() {\n      this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n      this.matchStart -= this.windowSize;\n      this.stringStart -= this.windowSize;\n      this.blockStart -= this.windowSize;\n\n      for (let i = 0; i < this.hashSize; ++i) {\n        let m = this.hashHead[i] & 0xffff;\n        this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n      }\n\n      for (let i = 0; i < this.windowSize; i++) {\n        let m = this.hashPrevious[i] & 0xffff;\n        this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n      }\n    }\n\n    insertString() {\n      let match;\n      let hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n      this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n      this.hashHead[hash] = this.stringStart;\n      this.currentHash = hash;\n      return match & 0xffff;\n    }\n\n    findLongestMatch(curMatch) {\n      let chainLen = 4096;\n      let niceLen = 258;\n      let scan = this.stringStart;\n      let match;\n      let bestEnd = this.stringStart + this.matchLength;\n      let bestLength = Math.max(this.matchLength, 3 - 1);\n      let limit = Math.max(this.stringStart - this.maxDist, 0);\n      let stringEnd = this.stringStart + 258 - 1;\n      let scanEnd1 = this.dataWindow[bestEnd - 1];\n      let scanEnd = this.dataWindow[bestEnd];\n      let data = this.dataWindow;\n\n      if (bestLength >= 32) {\n        chainLen >>= 2;\n      }\n\n      if (niceLen > this.lookAhead) {\n        niceLen = this.lookAhead;\n      }\n\n      do {\n        if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n          continue;\n        }\n\n        match = curMatch + 2;\n        scan += 2;\n        /* tslint:disable */\n\n        while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n          /* tslint:disable */\n        }\n\n        if (scan > bestEnd) {\n          this.matchStart = curMatch;\n          bestEnd = scan;\n          bestLength = scan - this.stringStart;\n\n          if (bestLength >= niceLen) {\n            break;\n          }\n\n          scanEnd1 = data[bestEnd - 1];\n          scanEnd = data[bestEnd];\n        }\n\n        scan = this.stringStart;\n      } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n      this.matchLength = Math.min(bestLength, this.lookAhead);\n      return this.matchLength >= 3;\n    }\n\n    updateHash() {\n      this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n    }\n\n    huffmanTallyLit(literal) {\n      this.arrDistances[this.bufferPosition] = 0;\n      this.arrLiterals[this.bufferPosition++] = literal;\n      this.treeLiteral.codeFrequencies[literal]++;\n      return this.bufferPosition >= 1 << 14;\n    }\n\n    huffmanTallyDist(dist, len) {\n      this.arrDistances[this.bufferPosition] = dist;\n      this.arrLiterals[this.bufferPosition++] = len - 3;\n      let lc = this.huffmanLengthCode(len - 3);\n      this.treeLiteral.codeFrequencies[lc]++;\n\n      if (lc >= 265 && lc < 285) {\n        this.extraBits += Math.floor((lc - 261) / 4);\n      }\n\n      let dc = this.huffmanDistanceCode(dist - 1);\n      this.treeDistances.codeFrequencies[dc]++;\n\n      if (dc >= 4) {\n        this.extraBits += Math.floor(dc / 2 - 1);\n      }\n\n      return this.bufferPosition >= 1 << 14;\n    }\n\n    huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock) {\n      this.treeLiteral.codeFrequencies[256]++;\n      this.treeLiteral.buildTree();\n      this.treeDistances.buildTree();\n      this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n      this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n      this.treeCodeLengths.buildTree();\n      let blTreeCodes = 4;\n\n      for (let i = 18; i > blTreeCodes; i--) {\n        if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n          blTreeCodes = i + 1;\n        }\n      }\n\n      let opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n      let static_len = this.extraBits;\n\n      for (let i = 0; i < 286; i++) {\n        static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n      }\n\n      for (let i = 0; i < 30; i++) {\n        static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n      }\n\n      if (opt_len >= static_len) {\n        // Force static trees.\n        opt_len = static_len;\n      }\n\n      if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n        this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n      } else if (opt_len == static_len) {\n        // Encode with static tree.\n        this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n        this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n        this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n        this.huffmanCompressBlock();\n        this.huffmanReset();\n      } else {\n        this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n        this.huffmanSendAllTrees(blTreeCodes);\n        this.huffmanCompressBlock();\n        this.huffmanReset();\n      }\n    }\n\n    huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock) {\n      this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n      this.pendingBufferAlignToByte();\n      this.pendingBufferWriteShort(storedLength);\n      this.pendingBufferWriteShort(~storedLength);\n      this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n      this.huffmanReset();\n    }\n\n    huffmanLengthCode(len) {\n      if (len === 255) {\n        return 285;\n      }\n\n      let code = 257;\n\n      while (len >= 8) {\n        code += 4;\n        len >>= 1;\n      }\n\n      return code + len;\n    }\n\n    huffmanDistanceCode(distance) {\n      let code = 0;\n\n      while (distance >= 4) {\n        code += 2;\n        distance >>= 1;\n      }\n\n      return code + distance;\n    }\n\n    huffmanSendAllTrees(blTreeCodes) {\n      this.treeCodeLengths.buildCodes();\n      this.treeLiteral.buildCodes();\n      this.treeDistances.buildCodes();\n      this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n      this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n      this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n      for (let rank = 0; rank < blTreeCodes; rank++) {\n        this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n      }\n\n      this.treeLiteral.writeTree(this.treeCodeLengths);\n      this.treeDistances.writeTree(this.treeCodeLengths);\n    }\n\n    huffmanReset() {\n      this.bufferPosition = 0;\n      this.extraBits = 0;\n      this.treeLiteral.reset();\n      this.treeDistances.reset();\n      this.treeCodeLengths.reset();\n    }\n\n    huffmanCompressBlock() {\n      for (let i = 0; i < this.bufferPosition; i++) {\n        let literalLen = this.arrLiterals[i] & 255;\n        let dist = this.arrDistances[i];\n\n        if (dist-- !== 0) {\n          let lc = this.huffmanLengthCode(literalLen);\n          this.treeLiteral.writeCodeToStream(lc);\n          let bits = Math.floor((lc - 261) / 4);\n\n          if (bits > 0 && bits <= 5) {\n            this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n          }\n\n          let dc = this.huffmanDistanceCode(dist);\n          this.treeDistances.writeCodeToStream(dc);\n          bits = Math.floor(dc / 2 - 1);\n\n          if (bits > 0) {\n            this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n          }\n        } else {\n          this.treeLiteral.writeCodeToStream(literalLen);\n        }\n      }\n\n      this.treeLiteral.writeCodeToStream(256);\n    }\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n\n\n    pendingBufferWriteBits(b, count) {\n      let uint = new Uint32Array(1);\n      uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n      this.pendingBufCache = uint[0];\n      this.pendingBufBitsInCache += count;\n      this.pendingBufferFlushBits();\n    }\n\n    pendingBufferFlush(isClose) {\n      this.pendingBufferFlushBits();\n\n      if (this.pendingBufLength > 0) {\n        let array = new Uint8Array(this.pendingBufLength);\n        array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n        this.stream.push(array);\n      }\n\n      this.pendingBufLength = 0;\n    }\n\n    pendingBufferFlushBits() {\n      let result = 0;\n\n      while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        this.pendingBufCache >>= 8;\n        this.pendingBufBitsInCache -= 8;\n        result++;\n      }\n\n      return result;\n    }\n\n    pendingBufferWriteByteBlock(data, offset, length) {\n      let array = data.subarray(offset, offset + length);\n      this.pendingBuffer.set(array, this.pendingBufLength);\n      this.pendingBufLength += length;\n    }\n\n    pendingBufferWriteShort(s) {\n      this.pendingBuffer[this.pendingBufLength++] = s;\n      this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    }\n\n    pendingBufferAlignToByte() {\n      if (this.pendingBufBitsInCache > 0) {\n        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      }\n\n      this.pendingBufCache = 0;\n      this.pendingBufBitsInCache = 0;\n    }\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n\n\n    static initHuffmanTree() {\n      let i = 0;\n\n      while (i < 144) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n        ARR_LITERAL_LENGTHS[i++] = 8;\n      }\n\n      while (i < 256) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n        ARR_LITERAL_LENGTHS[i++] = 9;\n      }\n\n      while (i < 280) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n        ARR_LITERAL_LENGTHS[i++] = 7;\n      }\n\n      while (i < 286) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n        ARR_LITERAL_LENGTHS[i++] = 8;\n      }\n\n      for (i = 0; i < 30; i++) {\n        ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n        ARR_DISTANCE_LENGTHS[i] = 5;\n      }\n    }\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n\n\n    close() {\n      do {\n        this.pendingBufferFlush(true);\n\n        if (!this.compressData(true)) {\n          this.pendingBufferFlush(true);\n          this.pendingBufferAlignToByte();\n\n          if (!this.noWrap) {\n            this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n            this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n          }\n\n          this.pendingBufferFlush(true);\n        }\n      } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n\n\n    destroy() {\n      this.stream = [];\n      this.stream = undefined;\n      this.pendingBuffer = undefined;\n      this.treeLiteral = undefined;\n      this.treeDistances = undefined;\n      this.treeCodeLengths = undefined;\n      this.arrLiterals = undefined;\n      this.arrDistances = undefined;\n      this.hashHead = undefined;\n      this.hashPrevious = undefined;\n      this.dataWindow = undefined;\n      this.inputBuffer = undefined;\n      this.pendingBufLength = undefined;\n      this.pendingBufCache = undefined;\n      this.pendingBufBitsInCache = undefined;\n      this.bufferPosition = undefined;\n      this.extraBits = undefined;\n      this.currentHash = undefined;\n      this.matchStart = undefined;\n      this.matchLength = undefined;\n      this.matchPrevAvail = undefined;\n      this.blockStart = undefined;\n      this.stringStart = undefined;\n      this.lookAhead = undefined;\n      this.totalBytesIn = undefined;\n      this.inputOffset = undefined;\n      this.inputEnd = undefined;\n      this.windowSize = undefined;\n      this.windowMask = undefined;\n      this.hashSize = undefined;\n      this.hashMask = undefined;\n      this.hashShift = undefined;\n      this.maxDist = undefined;\n      this.checkSum = undefined;\n      this.noWrap = undefined;\n    }\n\n  }\n\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  /**\n   * represent the Huffman Tree\n   */\n\n  return CompressedStreamWriter;\n})();\nlet CompressorHuffmanTree = /*#__PURE__*/(() => {\n  class CompressorHuffmanTree {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    constructor(writer, elementCount, minCodes, maxLength) {\n      this.writer = writer;\n      this.codeMinCount = minCodes;\n      this.maxLength = maxLength;\n      this.codeFrequency = new Uint16Array(elementCount);\n      this.lengthCount = new Int32Array(maxLength);\n    }\n\n    get treeLength() {\n      return this.codeCount;\n    }\n\n    get codeLengths() {\n      return this.codeLength;\n    }\n\n    get codeFrequencies() {\n      return this.codeFrequency;\n    }\n\n    setStaticCodes(codes, lengths) {\n      let temp = new Int16Array(codes.length);\n      temp.set(codes, 0);\n      this.codes = temp;\n      let lengthTemp = new Uint8Array(lengths.length);\n      lengthTemp.set(lengths, 0);\n      this.codeLength = lengthTemp;\n    }\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n\n\n    reset() {\n      for (let i = 0; i < this.codeFrequency.length; i++) {\n        this.codeFrequency[i] = 0;\n      }\n\n      this.codes = undefined;\n      this.codeLength = undefined;\n    }\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n\n\n    writeCodeToStream(code) {\n      this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    }\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n\n\n    buildCodes() {\n      let nextCode = new Int32Array(this.maxLength);\n      this.codes = new Int16Array(this.codeCount);\n      let code = 0;\n\n      for (let bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n        nextCode[bitsCount] = code;\n        code += this.lengthCount[bitsCount] << 15 - bitsCount;\n      }\n\n      for (let i = 0; i < this.codeCount; i++) {\n        let bits = this.codeLength[i];\n\n        if (bits > 0) {\n          this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n          nextCode[bits - 1] += 1 << 16 - bits;\n        }\n      }\n    }\n\n    static bitReverse(value) {\n      return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n    }\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n\n\n    getEncodedLength() {\n      let len = 0;\n\n      for (let i = 0; i < this.codeFrequency.length; i++) {\n        len += this.codeFrequency[i] * this.codeLength[i];\n      }\n\n      return len;\n    }\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n\n\n    calculateBLFreq(blTree) {\n      let maxCount;\n      let minCount;\n      let count;\n      let curLen = -1;\n      let i = 0;\n\n      while (i < this.codeCount) {\n        count = 1;\n        let nextLen = this.codeLength[i];\n\n        if (nextLen === 0) {\n          maxCount = 138;\n          minCount = 3;\n        } else {\n          maxCount = 6;\n          minCount = 3;\n\n          if (curLen !== nextLen) {\n            blTree.codeFrequency[nextLen]++;\n            count = 0;\n          }\n        }\n\n        curLen = nextLen;\n        i++;\n\n        while (i < this.codeCount && curLen === this.codeLength[i]) {\n          i++;\n\n          if (++count >= maxCount) {\n            break;\n          }\n        }\n\n        if (count < minCount) {\n          blTree.codeFrequency[curLen] += count;\n        } else if (curLen !== 0) {\n          blTree.codeFrequency[16]++;\n        } else if (count <= 10) {\n          blTree.codeFrequency[17]++;\n        } else {\n          blTree.codeFrequency[18]++;\n        }\n      }\n    }\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n\n\n    writeTree(blTree) {\n      let maxRepeatCount;\n      let minRepeatCount;\n      let currentRepeatCount;\n      let currentCodeLength = -1;\n      let i = 0;\n\n      while (i < this.codeCount) {\n        currentRepeatCount = 1;\n        let nextLen = this.codeLength[i];\n\n        if (nextLen === 0) {\n          maxRepeatCount = 138;\n          minRepeatCount = 3;\n        } else {\n          maxRepeatCount = 6;\n          minRepeatCount = 3;\n\n          if (currentCodeLength !== nextLen) {\n            blTree.writeCodeToStream(nextLen);\n            currentRepeatCount = 0;\n          }\n        }\n\n        currentCodeLength = nextLen;\n        i++;\n\n        while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n          i++;\n\n          if (++currentRepeatCount >= maxRepeatCount) {\n            break;\n          }\n        }\n\n        if (currentRepeatCount < minRepeatCount) {\n          while (currentRepeatCount-- > 0) {\n            blTree.writeCodeToStream(currentCodeLength);\n          }\n        } else if (currentCodeLength !== 0) {\n          blTree.writeCodeToStream(16);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n        } else if (currentRepeatCount <= 10) {\n          blTree.writeCodeToStream(17);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n        } else {\n          blTree.writeCodeToStream(18);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n        }\n      }\n    }\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n\n\n    buildTree() {\n      let codesCount = this.codeFrequency.length;\n      let arrTree = new Int32Array(codesCount);\n      let treeLength = 0;\n      let maxCount = 0;\n\n      for (let n = 0; n < codesCount; n++) {\n        let freq = this.codeFrequency[n];\n\n        if (freq !== 0) {\n          let pos = treeLength++;\n          let pPos = 0;\n\n          while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n            arrTree[pos] = arrTree[pPos];\n            pos = pPos;\n          }\n\n          arrTree[pos] = n;\n          maxCount = n;\n        }\n      }\n\n      while (treeLength < 2) {\n        arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n      }\n\n      this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n      let leafsCount = treeLength;\n      let nodesCount = leafsCount;\n      let child = new Int32Array(4 * treeLength - 2);\n      let values = new Int32Array(2 * treeLength - 1);\n\n      for (let i = 0; i < treeLength; i++) {\n        let node = arrTree[i];\n        let iIndex = 2 * i;\n        child[iIndex] = node;\n        child[iIndex + 1] = -1;\n        values[i] = this.codeFrequency[node] << 8;\n        arrTree[i] = i;\n      }\n\n      this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n      this.buildLength(child);\n    }\n\n    constructHuffmanTree(arrTree, treeLength, values, nodesCount, child) {\n      do {\n        let first = arrTree[0];\n        let last = arrTree[--treeLength];\n        let lastVal = values[last];\n        let pPos = 0;\n        let path = 1;\n\n        while (path < treeLength) {\n          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n            path++;\n          }\n\n          arrTree[pPos] = arrTree[path];\n          pPos = path;\n          path = pPos * 2 + 1;\n        }\n\n        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n          arrTree[path] = arrTree[pPos];\n        }\n\n        arrTree[path] = last;\n        let second = arrTree[0];\n        last = nodesCount++;\n        child[2 * last] = first;\n        child[2 * last + 1] = second;\n        let minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n        values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n        pPos = 0;\n        path = 1;\n        /* tslint:disable */\n\n        while (path < treeLength) {\n          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n            path++;\n          }\n\n          arrTree[pPos] = arrTree[path];\n          pPos = path;\n          path = pPos * 2 + 1;\n        }\n        /* tslint:disable */\n\n\n        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n          arrTree[path] = arrTree[pPos];\n        }\n\n        arrTree[path] = last;\n      } while (treeLength > 1);\n    }\n\n    buildLength(child) {\n      this.codeLength = new Uint8Array(this.codeFrequency.length);\n      let numNodes = Math.floor(child.length / 2);\n      let numLeafs = Math.floor((numNodes + 1) / 2);\n      let overflow = 0;\n\n      for (let i = 0; i < this.maxLength; i++) {\n        this.lengthCount[i] = 0;\n      }\n\n      overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n      if (overflow === 0) {\n        return;\n      }\n\n      let iIncreasableLength = this.maxLength - 1;\n\n      do {\n        while (this.lengthCount[--iIncreasableLength] === 0) {\n          /* tslint:disable */\n        }\n\n        do {\n          this.lengthCount[iIncreasableLength]--;\n          this.lengthCount[++iIncreasableLength]++;\n          overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n        } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n      } while (overflow > 0);\n\n      this.recreateTree(child, overflow, numLeafs);\n    }\n\n    recreateTree(child, overflow, numLeafs) {\n      this.lengthCount[this.maxLength - 1] += overflow;\n      this.lengthCount[this.maxLength - 2] -= overflow;\n      let nodePtr = 2 * numLeafs;\n\n      for (let bits = this.maxLength; bits !== 0; bits--) {\n        let n = this.lengthCount[bits - 1];\n\n        while (n > 0) {\n          let childPtr = 2 * child[nodePtr++];\n\n          if (child[childPtr + 1] === -1) {\n            this.codeLength[child[childPtr]] = bits;\n            n--;\n          }\n        }\n      }\n    }\n\n    calculateOptimalCodeLength(child, overflow, numNodes) {\n      let lengths = new Int32Array(numNodes);\n      lengths[numNodes - 1] = 0;\n\n      for (let i = numNodes - 1; i >= 0; i--) {\n        let childIndex = 2 * i + 1;\n\n        if (child[childIndex] !== -1) {\n          let bitLength = lengths[i] + 1;\n\n          if (bitLength > this.maxLength) {\n            bitLength = this.maxLength;\n            overflow++;\n          }\n\n          lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n        } else {\n          let bitLength = lengths[i];\n          this.lengthCount[bitLength - 1]++;\n          this.codeLength[child[childIndex - 1]] = lengths[i];\n        }\n      }\n\n      return overflow;\n    }\n\n  }\n\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  /**\n   * Checksum calculator, based on Adler32 algorithm.\n   */\n\n  return CompressorHuffmanTree;\n})();\nlet ChecksumCalculator = /*#__PURE__*/(() => {\n  class ChecksumCalculator {\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    static checksumUpdate(checksum, buffer, offset, length) {\n      let uint = new Uint32Array(1);\n      uint[0] = checksum;\n      let checksum_uint = uint[0];\n      let s1 = uint[0] = checksum_uint & 65535;\n      let s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n      while (length > 0) {\n        let steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n        length -= steps;\n\n        while (--steps >= 0) {\n          s1 = s1 + (uint[0] = buffer[offset++] & 255);\n          s2 = s2 + s1;\n        }\n\n        s1 %= ChecksumCalculator.checksumBase;\n        s2 %= ChecksumCalculator.checksumBase;\n      }\n\n      checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n      return checksum_uint;\n    }\n\n  }\n\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n})();\nconst CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nclass ZipArchive {\n  /**\n   * gets compression level\n   */\n  get compressionLevel() {\n    return this.level;\n  }\n  /**\n   * sets compression level\n   */\n\n\n  set compressionLevel(level) {\n    this.level = level;\n  }\n  /**\n   * gets items count\n   */\n\n\n  get length() {\n    if (this.files === undefined) {\n      return 0;\n    }\n\n    return this.files.length;\n  }\n  /**\n   * constructor for creating ZipArchive instance\n   */\n\n\n  constructor() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n\n  addItem(item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (let i = 0; i < this.files.length; i++) {\n      let file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  }\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  addDirectory(directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  }\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  getItem(index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  }\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  contains(item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  }\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  save(fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      zipArchive.saveInternal(fileName, false).then(() => {\n        resolve(zipArchive);\n      });\n    });\n  }\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  saveAsBlob() {\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      zipArchive.saveInternal('', true).then(blob => {\n        resolve(blob);\n      });\n    });\n  }\n\n  saveInternal(fileName, skipFileSave) {\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      let zipData = [];\n      let dirLength = 0;\n\n      for (let i = 0; i < zipArchive.files.length; i++) {\n        let compressedObject = this.getCompressedData(this.files[i]);\n        compressedObject.then(data => {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            let blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  destroy() {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (let i = 0; i < this.files.length; i++) {\n        let file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  }\n\n  getCompressedData(item) {\n    let zipArchive = this;\n    let promise = new Promise((resolve, reject) => {\n      if (item instanceof ZipArchiveItem) {\n        let reader = new FileReader();\n\n        reader.onload = () => {\n          let input = new Uint8Array(reader.result);\n          let data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            let length = 0;\n\n            for (let i = 0; i < data.compressedData.length; i++) {\n              length += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader.readAsArrayBuffer(item.data);\n      } else {\n        let data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  }\n\n  compressData(input, data, crc32Table) {\n    let compressor = new CompressedStreamWriter(true);\n    let currentIndex = 0;\n    let nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      let subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  }\n\n  constructZippedObject(zipParts, data, dirLength, isDirectory) {\n    let extFileAttr = 0;\n    let date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    let header = this.writeHeader(data, date);\n    let localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    let centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  }\n\n  writeHeader(data, date) {\n    let zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  }\n\n  writeZippedContent(fileName, zipData, localDirLen, skipFileSave) {\n    let cenDirLen = 0;\n    let buffer = [];\n\n    for (let i = 0; i < zipData.length; i++) {\n      let item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (let i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    let blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  }\n\n  writeCentralDirectory(data, localHeader, offset, externalFileAttribute) {\n    let directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  }\n\n  writeFooter(zipData, centralLength, localLength) {\n    let dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  }\n\n  getArrayBuffer(input) {\n    let a = new Uint8Array(input.length);\n\n    for (let j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  }\n\n  getBytes(value, offset) {\n    let bytes = '';\n\n    for (let i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  }\n\n  getModifiedTime(date) {\n    let modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  }\n\n  getModifiedDate(date) {\n    let modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  }\n\n  calculateCrc32Value(crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (let i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  }\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  static initCrc32Table() {\n    let i;\n\n    for (let j = 0; j < 256; j++) {\n      i = j;\n\n      for (let k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  }\n\n}\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\n\nclass ZipArchiveItem {\n  /**\n   * Get the name of archive item\n   * @returns string\n   */\n  get name() {\n    return this.fileName;\n  }\n  /**\n   * Set the name of archive item\n   * @param  {string} value\n   */\n\n\n  set name(value) {\n    this.fileName = value;\n  }\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n\n\n  constructor(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  destroy() {\n    this.fileName = undefined;\n    this.data = undefined;\n  }\n\n}\n/**\n * export ZipArchive class\n */\n\n\nexport { ZipArchive, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator }; //# sourceMappingURL=ej2-compression.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}